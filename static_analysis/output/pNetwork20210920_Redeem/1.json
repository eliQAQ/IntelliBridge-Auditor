{"Function call relationship": "PToken.redeem", "code": ["PToken.redeem:function redeem(\n        uint256 amount,\n        bytes memory userData,\n        string memory underlyingAssetRecipient\n    )\n        public\n    {\n        _burn(_msgSender(), amount, userData, \"\");\n        emit Redeem(_msgSender(), amount, underlyingAssetRecipient, userData);\n    }", "PToken._msgSender:function _msgSender() internal view override(ContextUpgradeable, ERC777GSNUpgreadable) returns (address payable) {\n        return GSNRecipientUpgradeable._msgSender();\n  }", "ERC777Upgradeable._burn:function _burn(\n        address from,\n        uint256 amount,\n        bytes memory data,\n        bytes memory operatorData\n    )\n        internal\n        virtual\n    {\n        require(from != address(0), \"ERC777: burn from the zero address\");\n\n        address operator = _msgSender();\n\n        _callTokensToSend(operator, from, address(0), amount, data, operatorData);\n\n        _beforeTokenTransfer(operator, from, address(0), amount);\n\n        // Update state variables\n        _balances[from] = _balances[from].sub(amount, \"ERC777: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n\n        emit Burned(operator, from, amount, data, operatorData);\n        emit Transfer(from, address(0), amount);\n    }", "SafeMathUpgradeable.sub:function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        require(b <= a, \"SafeMath: subtraction overflow\");\n        return a - b;\n    }", "ERC777Upgradeable._beforeTokenTransfer:function _beforeTokenTransfer(address operator, address from, address to, uint256 amount) internal virtual { }", "ERC777Upgradeable._callTokensToSend:function _callTokensToSend(\n        address operator,\n        address from,\n        address to,\n        uint256 amount,\n        bytes memory userData,\n        bytes memory operatorData\n    )\n        private\n    {\n        address implementer = _ERC1820_REGISTRY.getInterfaceImplementer(from, _TOKENS_SENDER_INTERFACE_HASH);\n        if (implementer != address(0)) {\n            IERC777SenderUpgradeable(implementer).tokensToSend(operator, from, to, amount, userData, operatorData);\n        }\n    }", "GSNRecipientUpgradeable._msgSender:function _msgSender() internal view virtual override returns (address payable) {\n        if (msg.sender != getHubAddr()) {\n            return msg.sender;\n        } else {\n            return _getRelayedCallSender();\n        }\n    }", "GSNRecipientUpgradeable.getHubAddr:function getHubAddr() public view virtual override returns (address) {\n        return _relayHub;\n    }", "GSNRecipientUpgradeable._getRelayedCallSender:function _getRelayedCallSender() private pure returns (address payable result) {\n        // We need to read 20 bytes (an address) located at array index msg.data.length - 20. In memory, the array\n        // is prefixed with a 32-byte length value, so we first add 32 to get the memory read index. However, doing\n        // so would leave the address in the upper 20 bytes of the 32-byte word, which is inconvenient and would\n        // require bit shifting. We therefore subtract 12 from the read index so the address lands on the lower 20\n        // bytes. This can always be done due to the 32-byte prefix.\n\n        // The final memory read index is msg.data.length - 20 + 32 - 12 = msg.data.length. Using inline assembly is the\n        // easiest/most-efficient way to perform this operation.\n\n        // These fields are not accessible from assembly\n        bytes memory array = msg.data;\n        uint256 index = msg.data.length;\n\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Load the 32 bytes word from memory with the address on the lower 20 bytes, and mask those.\n            result := and(mload(add(array, index)), 0xffffffffffffffffffffffffffffffffffffffff)\n        }\n        return result;\n    }"]}