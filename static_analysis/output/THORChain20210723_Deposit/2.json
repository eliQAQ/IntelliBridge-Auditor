{"Function call relationship": "THORChain20210723/THORChain_Router.THORChain_Router.depositWithExpiry->THORChain20210723/THORChain_Router.THORChain_Router.deposit", "code": ["function depositWithExpiry(address payable vault, address asset, uint amount, string memory memo, uint expiration) external payable {\n        require(block.timestamp < expiration, \"THORChain_Router: expired\");\n        deposit(vault, asset, amount, memo);\n    }", "function deposit(address payable vault, address asset, uint amount, string memory memo) public payable nonReentrant{\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success,) = vault.call{value:safeAmount}(\"\");\n            require(success);\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); // Transfer asset\n            vaultAllowance[vault][asset] += safeAmount; // Credit to chosen vault\n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }", "function safeTransferFrom(address _asset, uint _amount) internal returns(uint amount) {\n        uint _startBal = iERC20(_asset).balanceOf(address(this));\n        (bool success,) = _asset.call(abi.encodeWithSignature(\"transferFrom(address,address,uint256)\", msg.sender, address(this), _amount));\n        require(success);\n        return (iERC20(_asset).balanceOf(address(this)) - _startBal);\n    }", "function deposit(address payable vault, address asset, uint amount, string memory memo) public payable nonReentrant{\n        uint safeAmount;\n        if(asset == address(0)){\n            safeAmount = msg.value;\n            (bool success,) = vault.call{value:safeAmount}(\"\");\n            require(success);\n        } else if(asset == RUNE) {\n            safeAmount = amount;\n            iRUNE(RUNE).transferTo(address(this), amount);\n            iERC20(RUNE).burn(amount);\n        } else {\n            safeAmount = safeTransferFrom(asset, amount); // Transfer asset\n            vaultAllowance[vault][asset] += safeAmount; // Credit to chosen vault\n        }\n        emit Deposit(vault, asset, safeAmount, memo);\n    }", "function safeTransferFrom(address _asset, uint _amount) internal returns(uint amount) {\n        uint _startBal = iERC20(_asset).balanceOf(address(this));\n        (bool success,) = _asset.call(abi.encodeWithSignature(\"transferFrom(address,address,uint256)\", msg.sender, address(this), _amount));\n        require(success);\n        return (iERC20(_asset).balanceOf(address(this)) - _startBal);\n    }"]}