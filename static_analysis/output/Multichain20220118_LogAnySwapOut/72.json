{"Function call relationship": "MultichainV7Router.anySwapOut", "code": ["MultichainV7Router.anySwapOut:function anySwapOut(\n        address token,\n        string calldata to,\n        uint256 amount,\n        uint256 toChainID\n    ) external whenNotPaused(Swapout_Paused_ROLE) nonReentrant {\n        bytes32 swapoutID = IRouterSecurity(routerSecurity).registerSwapout(\n            token,\n            msg.sender,\n            to,\n            amount,\n            toChainID,\n            \"\",\n            \"\"\n        );\n        assert(IRouterMintBurn(token).burn(msg.sender, amount));\n        emit LogAnySwapOut(swapoutID, token, msg.sender, to, amount, toChainID);\n    }", "MultichainV7Router.anySwapOut:function anySwapOut(\n        address token,\n        string calldata to,\n        uint256 amount,\n        uint256 toChainID\n    ) external whenNotPaused(Swapout_Paused_ROLE) nonReentrant {\n        bytes32 swapoutID = IRouterSecurity(routerSecurity).registerSwapout(\n            token,\n            msg.sender,\n            to,\n            amount,\n            toChainID,\n            \"\",\n            \"\"\n        );\n        assert(IRouterMintBurn(token).burn(msg.sender, amount));\n        emit LogAnySwapOut(swapoutID, token, msg.sender, to, amount, toChainID);\n    }", "RouterMintBurnWrapper.burn:function burn(address from, uint256 amount)\n        external\n        override\n        onlyAuth\n        returns (bool)\n    {\n        assert(ITokenMintBurn(token).burnFrom(from, amount));\n        return true;\n    }"]}