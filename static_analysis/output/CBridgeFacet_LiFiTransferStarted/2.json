{"Function call relationship": "CBridgeFacet/src/Facets/GenericBridgeFacet.GenericBridgeFacet.swapAndStartBridgeTokensGeneric", "code": ["function swapAndStartBridgeTokensGeneric(\n        LiFiData memory _lifiData,\n        LibSwap.SwapData[] calldata _swapData,\n        BridgeData memory _bridgeData\n    ) public payable {\n        uint256 _fromTokenBalance = LibAsset.getOwnBalance(_bridgeData.assetId);\n\n        // Swap\n        for (uint8 i; i < _swapData.length; i++) {\n            LibSwap.swap(_lifiData.transactionId, _swapData[i]);\n        }\n\n        require(\n            LibAsset.getOwnBalance(_bridgeData.assetId) - _fromTokenBalance >= _bridgeData.amount,\n            \"ERR_INVALID_AMOUNT\"\n        );\n\n        _startBridge(_bridgeData);\n\n        emit LiFiTransferStarted(\n            _lifiData.transactionId,\n            _lifiData.integrator,\n            _lifiData.referrer,\n            _lifiData.sendingAssetId,\n            _lifiData.receivingAssetId,\n            _lifiData.receiver,\n            _lifiData.amount,\n            _lifiData.destinationChainId,\n            block.timestamp\n        );\n    }", "function _startBridge(BridgeData memory _bridgeData) internal {\n        LibAsset.approveERC20(IERC20(_bridgeData.assetId), _bridgeData.callTo, _bridgeData.amount);\n        // solhint-disable avoid-low-level-calls\n        (bool success, bytes memory res) = _bridgeData.callTo.call{ value: msg.value }(_bridgeData.callData);\n        if (!success) {\n            string memory reason = LibUtil.getRevertMsg(res);\n            revert(reason);\n        }\n    }"]}