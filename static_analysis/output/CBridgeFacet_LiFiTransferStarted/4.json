{"Function call relationship": "CBridgeFacet/src/Facets/AnyswapFacet.AnyswapFacet.swapAndStartBridgeTokensViaAnyswap", "code": ["function swapAndStartBridgeTokensViaAnyswap(\n        LiFiData memory _lifiData,\n        LibSwap.SwapData[] calldata _swapData,\n        AnyswapData memory _anyswapData\n    ) public payable {\n        if (_anyswapData.token != address(0)) {\n            address underlyingToken = IAnyswapToken(_anyswapData.token).underlying();\n            uint256 _fromTokenBalance = LibAsset.getOwnBalance(underlyingToken);\n\n            // Swap\n            for (uint8 i; i < _swapData.length; i++) {\n                LibSwap.swap(_lifiData.transactionId, _swapData[i]);\n            }\n\n            uint256 _postSwapBalance = LibAsset.getOwnBalance(underlyingToken) - _fromTokenBalance;\n\n            require(_postSwapBalance > 0, \"ERR_INVALID_AMOUNT\");\n\n            _anyswapData.amount = _postSwapBalance;\n        } else {\n            uint256 _fromBalance = address(this).balance;\n\n            // Swap\n            for (uint8 i; i < _swapData.length; i++) {\n                LibSwap.swap(_lifiData.transactionId, _swapData[i]);\n            }\n\n            require(address(this).balance - _fromBalance >= _anyswapData.amount, \"ERR_INVALID_AMOUNT\");\n\n            uint256 _postSwapBalance = address(this).balance - _fromBalance;\n\n            require(_postSwapBalance > 0, \"ERR_INVALID_AMOUNT\");\n\n            _anyswapData.amount = _postSwapBalance;\n        }\n\n        _startBridge(_anyswapData);\n\n        emit LiFiTransferStarted(\n            _lifiData.transactionId,\n            _lifiData.integrator,\n            _lifiData.referrer,\n            _lifiData.sendingAssetId,\n            _lifiData.receivingAssetId,\n            _lifiData.receiver,\n            _lifiData.amount,\n            _lifiData.destinationChainId,\n            block.timestamp\n        );\n    }", "function _startBridge(AnyswapData memory _anyswapData) internal {\n        // Check chain id\n        require(block.chainid != _anyswapData.toChainId, \"Cannot bridge to the same network.\");\n\n        if (_anyswapData.token != address(0)) {\n            // Give Anyswap approval to bridge tokens\n            LibAsset.approveERC20(\n                IERC20(IAnyswapToken(_anyswapData.token).underlying()),\n                _anyswapData.router,\n                _anyswapData.amount\n            );\n\n            IAnyswapRouter(_anyswapData.router).anySwapOutUnderlying(\n                _anyswapData.token,\n                _anyswapData.recipient,\n                _anyswapData.amount,\n                _anyswapData.toChainId\n            );\n        } else {\n            IAnyswapRouter(_anyswapData.router).anySwapOutNative{ value: _anyswapData.amount }(\n                _anyswapData.token,\n                _anyswapData.recipient,\n                _anyswapData.toChainId\n            );\n        }\n    }"]}