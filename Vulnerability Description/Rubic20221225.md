## 漏洞核心
合约中的 routerCallNative 函数中会对可以调用的 router 进行判断，但是由于项目方的错误，将 USDC Token 地址`0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48`设置为 router 地址，分析如下：
![](https://img.foresightnews.pro/202212/9e44fd9887d687e6e23e9513a50e5cd5.png?x-oss-process=style/scale70)

用户可以通过`0x3335A88bb18fD3b6824b59Af62b50CE494143333/RubicProxy-label.sol`的RubicProxy合约中的routerCallNative函数进行Native代币兑换。在进行兑换前，会先检查用户传入的目标Router是否在协议的白名单中：
```
 function routerCallNative(BaseCrossChainParams calldata _params, bytes calldata _data)
    external
    payable
    nonReentrant
    whenNotPaused
    eventEmitter(_params)
{
    if (!availableRouters.contains(_params.router)) {
        revert RouterNotAvailable();
    }

    IntegratorFeeInfo memory _info = integratorToFeeInfo[_params.integrator];

    uint256 _amountIn = accrueTokenFees(
        _params.integrator,
        _info,
        accrueFixedCryptoFee(_params.integrator, _info),
        0,
        address(0)
    );

    AddressUpgradeable.functionCallWithValue(_params.router, _data, _amountIn);
}
```
由于_data没有限制，攻击者通过`AddressUpgradeable.functionCallWithValue`指定执行该USDC合约的transferFrom函数将其他用户授权给RubicProxy合约的 USDC 转出（普通的router的transferFrom已经被重写）。

## 参考资料
<https://foresightnews.pro/article/detail/21961>