# 历年跨链合约恶意交易详解（五）——MeterPassport20220206

# 漏洞合约

```
/**
        @notice Initiates a transfer using a specified handler contract.
        @notice Only callable when Bridge is not paused.
        @param destinationChainID ID of chain deposit will be bridged to.
        @param resourceID ResourceID used to find address of handler to be used for deposit.
        @param data Additional data to be passed to specified handler.
        @notice Emits {Deposit} event.
     */
    function deposit(uint8 destinationChainID, bytes32 resourceID, bytes calldata data) external payable whenNotPaused {
        uint256 fee = _getFee(destinationChainID);

        require(msg.value == fee, "Incorrect fee supplied");

        address handler = _resourceIDToHandlerAddress[resourceID];
        require(handler != address(0), "resourceID not mapped to handler");

        uint64 depositNonce = ++_depositCounts[destinationChainID];
        _depositRecords[depositNonce][destinationChainID] = data;

        IDepositExecute depositHandler = IDepositExecute(handler);
        depositHandler.deposit(resourceID, destinationChainID, depositNonce, msg.sender, data);

        emit Deposit(destinationChainID, resourceID, depositNonce);
    }
```

```
function deposit(
        bytes32 resourceID,
        uint8   destinationChainID,
        uint64  depositNonce,
        address depositer,
        bytes   calldata data
    ) external override onlyBridge {
        bytes   memory recipientAddress;
        uint256        amount;
        uint256        lenRecipientAddress;

        assembly {

            amount := calldataload(0xC4)

            recipientAddress := mload(0x40)
            lenRecipientAddress := calldataload(0xE4)
            mstore(0x40, add(0x20, add(recipientAddress, lenRecipientAddress)))

            calldatacopy(
                recipientAddress, // copy to destinationRecipientAddress
                0xE4, // copy from calldata @ 0x104
                sub(calldatasize(), 0xE) // copy size (calldatasize - 0x104)
            )
        }

        address tokenAddress = _resourceIDToTokenContractAddress[resourceID];
        require(_contractWhitelist[tokenAddress], "provided tokenAddress is not whitelisted");
        
        // ether case, the weth already in handler, do nothing
        if (tokenAddress != _wtokenAddress) {
            if (_burnList[tokenAddress]) {
                burnERC20(tokenAddress, depositer, amount);
            } else {
                lockERC20(tokenAddress, depositer, address(this), amount);
            }
        }

        _depositRecords[destinationChainID][depositNonce] = DepositRecord(
            tokenAddress,
            uint8(lenRecipientAddress),
            destinationChainID,
            resourceID,
            recipientAddress,
            depositer,
            amount
        );
    }
```

# 漏洞合约地址与攻击方地址

漏洞合约地址1: [0xde4fc7c3c5e7be3f16506fcc790a8d93f8ca0b40](https://etherscan.io/address/0xde4fc7c3c5e7be3f16506fcc790a8d93f8ca0b40#code)
漏洞合约地址2: [0xa2a22b46b8df38cd7c55e6bf32ea5a32637cf2b1](https://etherscan.io/address/0xa2a22b46b8df38cd7c55e6bf32ea5a32637cf2b1#code)
攻击方地址:[0x8d3d13cac607b7297ff61a5e1e71072758af4d01](https://etherscan.io/address/0x8d3d13cac607b7297ff61a5e1e71072758af4d01)

# 具体交易

tx:[0x2d3987963b77159cfe4f820532d729b0364c7f05511f23547765c75b110b629c](https://etherscan.io/tx/0x2d3987963b77159cfe4f820532d729b0364c7f05511f23547765c75b110b629c)

# 具体分析

该漏洞与 QBridge 的一个已知漏洞相似，源于跨链桥 deposit 函数的设计缺陷。该桥同时提供了处理 ERC20 代币的 deposit 函数和处理原生代币（如 ETH，通常包装为 WETH）的 depositETH 函数。攻击者利用这一点，调用了为 ERC20设计的 deposit 函数，但却传入了指向包装后原生代币（_wtokenAddress）的 resourceid。当执行流进入内部的 depositHandler.deposit 逻辑时，一个关键检查 tokenAddress != _wtokenAddress （可能用于区分或特殊处理原生代币存款）被无效化，因为攻击者提供的 resourceid 使得 tokenAddress 等于 _wtokenAddress。这导致合约跳过了实际的 ERC20 代币转移验证步骤，但仍然成功触发（emit）了存款事件。桥的后端监控到这个事件后，误以为发生了有效存款，于是在目标链上为攻击者错误地铸造了代币，而攻击者实际上并未在源链锁定相应资产。

# 具体事件


# 参考链接

链接: [https://zhuanlan.zhihu.com/p/464789562](https://zhuanlan.zhihu.com/p/464789562)

