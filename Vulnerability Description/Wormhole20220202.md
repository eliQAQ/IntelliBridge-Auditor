## 漏洞攻击流程

### 步骤一：

攻击者使用假 sysvar account调用“verify_signatures”函数：https://solscan.io/tx/25Zu1L2Q9uk998d5GMnX43t9u9eVBKvbVtgHndkc2GmUFed8Pu73LGW6hiDsmGXHykKUTLkvUdh4yXPdL3Jo4wVS①以伪造的“sysvar account”作为参数调用的“verify_signatures”函数：

![](https://pic3.zhimg.com/v2-81dedfef4a906a9e74d93358b588907e_1440w.jpg)

相比之下，以下截图是以真实的“sysvar account”作为参数的“verify_signatures”函数：

![](https://pic3.zhimg.com/v2-ca61d06d51ddb62e9a6c27191a4df082_1440w.jpg)


② “verify_signatures”函数从 sysvar (L92) 加载当前指令。

![](https://pica.zhimg.com/v2-755a85a434edb46ac8991729ffeb72e0_1440w.jpg)


③ 然而，函数“load_current_index”并不能验证“sysvar account”是否真的是“system sysvar”。由于从“sysvar”中检索到的当前指令（L92）是由攻击者控制的，因此它可以顺利通过以下验证过程。

### 步骤二：

攻击者随后使用上一步验证的签名调用“post_vaa”函数，并创建一个恶意消息帐户，声明要铸造12万枚wETH：https://solscan.io/tx/2SohoVoPDSdzgsGCgKQPByKQkLAXHrYmvtE7EEqwKi3qUBTGDDJ7DcfYS7YJC2f8xwKVVa6SFUpH5MZ5xcyn1BCK

![](https://pic2.zhimg.com/v2-ab9b9067e227e5ab98e2da0225eba8e3_1440w.jpg)

① Account2 是通过“verify_signatures”指令生成的签名集。② Account3 是将在“complete_wrapped”函数中使用的消息帐户。



### 步骤三：

攻击者调用“complete_wrapped”函数读取恶意消息账户中的数据并铸造 12万枚wETH：https://solscan.io/tx/2zCz2GgSoSS68eNJENWrYB48dMM1zmH8SZkgYneVDv2G4gRsVfwu5rNXtK5BKFxn7fSqX9BvrBc1rdPAeBEcD6Es

![](https://picx.zhimg.com/v2-406392edcb9d3debce62321828188a69_1440w.jpg)

① Account3 是“post_vaa”函数生成的消息账户。

②Account6 是“收件人”地址，用于接收铸造的Wormhole ETH。③ Account9 是 Wormhole ETH 的铸币机构，是一个 PDA（程序派生地址）。这就是为什么在签名验证通过后，攻击者可以直接铸造代币。

### 步骤四：

部分铸造的 wETH 被转移到以太坊，其余的被交换到 USDC 和 SOL：

https://solscan.io/tx/j3jUDG43di8Dsg7Q3jQhstamtBovu1GLqnDJ7yNvM3r4pnK9e7uqgt9uBobCjT5S1BKhZZFQNQwDxypEYqLknec
https://solscan.io/tx/5UaqPus91wvAzKNve6L8YAHsESomZQ7GWi37gPFyzTHcXNMZA641bb8m8txo7bS7A5cAnzKDKYyiKcQC8GgDcAuf
https://solscan.io/tx/3AugXqrXunBa96YfqENhPBiWZWpnSnJdqAHS64qcHTVU9KtfGon8cN9cUuXsDmBobBBXjYUtuRxnYxgERS42nh6G
https://solscan.io/tx/2SndtH3tU4j6v14HJzEde3d3dnpdHqTPn4VnvhTj4zKLo26H5kmtCwjn2nANfjXNVbmFsyEGtD4Jte25azsPwaRk


## 合约漏洞分析


这个漏洞的根本原因是在验证签名过程（“verify_signatures”）中，程序使用了一个在Solana更新至1.8.0时即被废弃的“load_current_index”函数。该函数不会验证输入的“sysvar account”是否真的是“system sysvar”，从而攻击者可以趁机伪造这个关键帐户。

```

let secp_ix = solana_program::sysvar::instructions::load_instruction_at(
    secp_ix_index as usize,
    &accs.instruction_acc.try_borrow_mut_data()?,
)
```

为了防止将来此类问题的发生，必须检查并验证函数使用的所有帐户。特别是在该案例中，由于部分检查过程依赖于外部调用，而外部调用的可靠性被过度信任，从而引入了风险。



## 参考链接
https://learnblockchain.cn/article/3650

https://zhuanlan.zhihu.com/p/464456111

https://research.kudelskisecurity.com/2022/02/03/quick-analysis-of-the-wormhole-attack/