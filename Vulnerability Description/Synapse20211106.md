与Nerve的漏洞类似。   
文件地址：`Synapse20211106/0x88E7af57270F70BCF32CD61fff0Ff635775C8f7c
/MetaSwapUtils-label.sol`
## 基础信息

### 攻击者：

0x3ab92d06f5f2a33d8f45f836607f8da68cab81e8

### 攻击tx：
0xe2f66358873553990911c15d2bbe8ffea72ddba86dfa64e32cde7ae998f09f35  
0x415d4ad8c6237b6d110fc0ea66f0d1b4a3f13ac196ac5b708b037c07c83d69f2

## 攻击流程
1、首先攻击者通过 Firebird Router 在 Metaswap.sol 上调用 swap() 函数和 removeLiquidityOneToken() 函数，先将 nUSD 兑换成 nUSD-LP 代币，再移除 nUSD-LP 获取 USDC。  
2、攻击者通过 MetaswapDeposit 合约中的 addLiquidity() 函数用 USDC 添加流动性换取 nUSD-LP。  
3、攻击者通过 MetaswapDeposit 合约中的 removeLiquidityOneToken() 函数用 nUSD-LP 移除流动性换取 nUSD，然后依次循环，不断套利。

## 漏洞细节
在 Metapool 中当用户可以直接用资产 D 去兑换 A、B 或 C，但在兑换到 A、B、C 的 LP 代币时，需要计算 LP 代码基本虚拟价格，而 Saddle Metaswap 合约中忽略计算 LP 代币基本虚拟价格的检查




在 MetaPool 中，有两个重要的功能，即swap和swapUnderlying。具体来说，前者用于交换 LP 代币和矿池稳定币，而后者用于交换矿池稳定币和底层稳定币。该池子 fUSDT 是矿池稳定币，而 BUSD、USD 和 USDC 是底层稳定币。

_calculateSwap函数：
```
function _calculateSwap(
    SwapUtils.Swap storage self,
    uint8 tokenIndexFrom,
    uint8 tokenIndexTo,
    uint256 dx,
    uint256 baseVirtualPrice
) internal view returns (uint256 dy, uint256 dyFee) {
    uint256[] memory xp = _xp(self, baseVirtualPrice);
    require(
        tokenIndexFrom < xp.length && tokenIndexTo < xp.length,
        "Token index out of range"
    );
    uint256 x =
        dx.mul(self.tokenPrecisionMultipliers[tokenIndexFrom]).add(
            xp[tokenIndexFrom]
        );
    uint256 y =
        SwapUtils.getY(
            self._getAPrecise(),
            tokenIndexFrom,
            tokenIndexTo,
            x,
            xp
        );
    dy = xp[tokenIndexTo].sub(y).sub(1); //忽略了虚拟价格
    dyFee = dy.mul(self.swapFee).div(FEE_DENOMINATOR);
    dy = dy.sub(dyFee).div(self.tokenPrecisionMultipliers[tokenIndexTo]);
}
```

removeLiquidityOneToken调用的_calculateWithdrawOneToken调用的_calculateWithdrawOneTokenDY函数：

```
function _calculateWithdrawOneTokenDY(
    SwapUtils.Swap storage self,
    uint8 tokenIndex,
    uint256 tokenAmount,
    uint256 baseVirtualPrice,
    uint256 totalSupply
)
    internal
    view
    returns (
        uint256,
        uint256,
        uint256
    )
{
    // Get the current D, then solve the stableswap invariant
    // y_i for D - tokenAmount
    uint256[] memory xp = _xp(self, baseVirtualPrice);
    require(tokenIndex < xp.length, "Token index out of range");

    CalculateWithdrawOneTokenDYInfo memory v =
        CalculateWithdrawOneTokenDYInfo(0, 0, 0, 0, self._getAPrecise(), 0);
    v.d0 = SwapUtils.getD(xp, v.preciseA);
    v.d1 = v.d0.sub(tokenAmount.mul(v.d0).div(totalSupply));

    require(tokenAmount <= xp[tokenIndex], "Withdraw exceeds available");

    v.newY = SwapUtils.getYD(v.preciseA, tokenIndex, xp, v.d1);

    uint256[] memory xpReduced = new uint256[](xp.length);

    v.feePerToken = SwapUtils._feePerToken(self.swapFee, xp.length);
    for (uint256 i = 0; i < xp.length; i++) {
        v.xpi = xp[i];
        // if i == tokenIndex, dxExpected = xp[i] * d1 / d0 - newY
        // else dxExpected = xp[i] - (xp[i] * d1 / d0)
        // xpReduced[i] -= dxExpected * fee / FEE_DENOMINATOR
        xpReduced[i] = v.xpi.sub(
            (
                (i == tokenIndex)
                    ? v.xpi.mul(v.d1).div(v.d0).sub(v.newY)
                    : v.xpi.sub(v.xpi.mul(v.d1).div(v.d0))
            )
                .mul(v.feePerToken)
                .div(FEE_DENOMINATOR)
        );
    }

    uint256 dy =
        xpReduced[tokenIndex].sub(
            SwapUtils.getYD(v.preciseA, tokenIndex, xpReduced, v.d1)
        );

    if (tokenIndex == xp.length.sub(1)) {
        dy = dy.mul(BASE_VIRTUAL_PRICE_PRECISION).div(baseVirtualPrice); //计算了虚拟价格
    }
    dy = dy.sub(1).div(self.tokenPrecisionMultipliers[tokenIndex]);

    return (dy, v.newY, xp[tokenIndex]);
}

```

## 参考资料

<https://www.jinse.cn/news/blockchain/1172394.html>
