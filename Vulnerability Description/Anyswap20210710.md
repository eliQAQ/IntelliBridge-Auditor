## 攻击流程

在以太坊网络上，每个要被桥接的代币都有自己的代理工厂合约。攻击者能够利用该合约，直接向不同的地址铸造代币，然后再把它们重新汇集到最初发送交易的钱包中。

调用工厂（铸币）合约的receive函数

每笔交易使用一个新的地址作为签名来躲避马虎的权限检查系统

支付0.005 ETH chargeFee

将参数设置为所需的地址，该地址接收铸造的代币

重复x次
![](https://raw.githubusercontent.com/RektHQ/Assets/main/images/2021/7/chainswap-code.png
)

在BSC上，根据ChainSwap的事后分析，该漏洞总共针对20个代币。

以NFT平台WilderWorld为例，这是40笔重复交易中的一次，每次都铸造50万个WILD代币。

这2000万个WILD随后被以大约650个WBNB的价格，刚刚超过20万美元，在PancakeSwap出售，在这个过程中有效地耗尽了WILD/WBNB池的资金。

当黑客攻击结束的时候，他们的钱包里已经装满了各种代币，总价值约为440万美元。

![](https://raw.githubusercontent.com/RektHQ/Assets/main/images/2021/7/chainswap-tokens.png)

证据出现在攻击者的以太坊钱包中，以一长串0.005ETH交易的形式出现，每一笔都是通过Chainswap桥接的新造代币的证据。

最后几笔交易显示，攻击者通过1inch兑现了一些从BSC桥接的ETH--一系列5笔交易，共计456个ETH，在撰写本文时约为935,000美元。

## 漏洞分析

跨链代币额度的代码中存在一个漏洞。链上的兑换桥额度本应由签名节点自动增加，以实现更去中心化的运作方式，无需人工干预。然而，由于代码中的逻辑缺陷，攻击者利用该漏洞，使得未被白名单允许的非法地址也能自动增加额度，从而实现了攻击。

```
function receive(uint256 fromChainId, address to, uint256 nonce, uint256 volume, Signature[] memory signatures) virtual external payable {
        _chargeFee();
        require(received[fromChainId][to][nonce] == 0, 'withdrawn already');
        uint N = signatures.length;
        require(N >= Factory(factory).getConfig(_minSignatures_), 'too few signatures');
        for(uint i=0; i<N; i++) {
            for(uint j=0; j<i; j++)
                require(signatures[i].signatory != signatures[j].signatory, 'repetitive signatory');
            bytes32 structHash = keccak256(abi.encode(RECEIVE_TYPEHASH, fromChainId, to, nonce, volume, signatures[i].signatory));
            bytes32 digest = keccak256(abi.encodePacked("\x19\x01", _DOMAIN_SEPARATOR, structHash));
            address signatory = ecrecover(digest, signatures[i].v, signatures[i].r, signatures[i].s);
            require(signatory != address(0), "invalid signature");
            require(signatory == signatures[i].signatory, "unauthorized");
            _decreaseAuthQuota(signatures[i].signatory, volume);
            emit Authorize(fromChainId, to, nonce, volume, signatory);
        }
        received[fromChainId][to][nonce] = volume;
        _receive(to, volume);
        emit Receive(fromChainId, to, nonce, volume);
    }
```
```
    function _decreaseAuthQuota(address signatory, uint decrement) virtual internal returns (uint quota) {
        quota = authQuotaOf[signatory].sub(decrement);
        authQuotaOf[signatory] = quota;
        emit DecreaseAuthQuota(signatory, decrement, quota);
    }
    event DecreaseAuthQuota(address indexed signatory, uint decrement, uint quota);
```
```
    modifier updateAutoQuota(address signatory) virtual {
        uint quota = authQuotaOf(signatory);
        if(_authQuotas[signatory] != quota) {
            _authQuotas[signatory] = quota;
            lasttimeUpdateQuotaOf[signatory] = now;
        }
        _;
    }
```


## 参考链接

https://rekt.news/zh/chainswap-rekt

https://chain-swap.medium.com/chainswap-exploit-11-july-2021-post-mortem-6e4e346e5a32