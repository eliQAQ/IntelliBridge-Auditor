LIFI20220320: 合约涉及call函数但未检查call的数据，攻击者可以借此转账授权给该合约的用户的代币。  
LIFI20240716：同LIFI20220320  
Multichain20220118：未检查输入合约类型是否符合AnyswapV1ERC20的标准和permit的返回值，导致跳过了permit函数，将恶意合约填写的标的资产转给了攻击者。  
Nerve20211115：swap未计算虚拟价格导致LP被低估，攻击者通过兑换更多的LP然后再换回原资产获利。  
Nomad20220801：合约升级修改了process函数但初始化函数未修改，导致confirmAt[0]=1，使得任意消息都能通过梅克尔树的检查。  
PolyNetwork20210810：_executeCrossChainTx中_toContract.call未作严格检查且_toContract中有修改owner的函数（external）, 攻击者使用hash碰撞出和该函数前4个字节相同的_method并传入_args修改owner为自己然后就能unlock代币转给自己了。  
QBridge20220128：合约中为标准代币和原生代币制作了两个不同的函数（deposit和depositETH）但使用的tokenAddress池子是相同的且deposit中无需直接支付代币，由于原生代币是0地址所以充值空过然后触发了充值事件导致目标链上用户凭空获取了代币。  
Rubic20221225：项目方错误地将 USDC Token 地址设置为 router 地址，且对于call的数据没有检查，导致可以指定_data为transferFrom转出了授权给该代币地址的用户的代币。  
SocketGateway20240117： 新router的 WETH 与 ETH 的转换函数中当amount为0时转换结果检查会一定通过，此时用户可以指定call的swapExtraData调用token的transferfrom函数将授权的代币转给自己。   
Synapse20211106：同Nerve20211115
XBridge20240424：listToken函数（标记跨链代币的对应关系）可以被外部调用且当传入的地址_baseToken==_correspondingToken相同时可以认为用户是代币的主人，尽管检查了存在性但是chain可以设置任意值，只要不重复即可，转账时token为显示输入，只检查owner，导致认为攻击者是token的owner，攻击者转出代币。   
chainswap20210711：该跨链桥检查签名有效性的函数基本上是摆设，只检查了签名的完整性但是没有检查签名的有效性，默认签名是正确的，没有处理不存在的情况，并且添加配额时使用到了签名地址的上次签名时间，同样没有处理不存在的情况，导致会给一个乘时间戳的配额给该地址，使得任意签名都能拥有极大的配额。因此用户自己随便签个名就能通过检验，随意调用receive函数取钱。此外事件发生前管理者还将需要的验证数量设定为了1，更加便于攻击者攻击了。  
meterpassport20220206：类似QBridge20220128  
pNetwork20210920：链下负责日志的代码法不管合法的还是故障的日志都被提取并错误地处理，导致伪造事件骗钱。  

---

thorchain20210723：待讨论，参考以下资料：
<https://www.mytokencap.com/news/277392.html>  
<https://blog.csdn.net/eliforsharon/article/details/146735675>  
<https://learnblockchain.cn/article/7089>  
<https://thearchitect.notion.site/THORChain-Incident-07-22-874a06db7bf8466caf240e1823697e35>  


此外，并没有找到Multichain20230215和QANXBridge20220518的信息，前者倒是有一个2023年7月的，但是认为是私钥泄露，后者也只找到一篇报道，也是私钥泄露。