该攻击仅由一次对process()函数的调用组成。  
函数均位于`packages/contracts-core/contracts/Replica.sol`

先看process函数：

```
 /**
 * @notice Given formatted message, attempts to dispatch
 * message payload to end recipient.
 * @dev Recipient must implement a `handle` method (refer to IMessageRecipient.sol)
 * Reverts if formatted message's destination domain is not the Replica's domain,
 * if message has not been proven,
 * or if not enough gas is provided for the dispatch transaction.
 * @param _message Formatted message
 * @return _success TRUE iff dispatch transaction succeeded
 */
function process(bytes memory _message) public returns (bool _success) {
    // ensure message was meant for this domain
    bytes29 _m = _message.ref(0);
    require(_m.destination() == localDomain, "!destination");
    // ensure message has been proven
    bytes32 _messageHash = _m.keccak();
    require(acceptableRoot(messages[_messageHash]), "!proven");
    // check re-entrancy guard
    require(entered == 1, "!reentrant");
    entered = 0;
    // update message status as processed
    messages[_messageHash] = LEGACY_STATUS_PROCESSED;
    // call handle function
    IMessageRecipient(_m.recipientAddress()).handle(
        _m.origin(),
        _m.nonce(),
        _m.sender(),
        _m.body().clone()
    );
    // emit process results
    emit Process(_messageHash, true, "");
    // reset re-entrancy guard
    entered = 1;
    // return true
    return true;
}
```

在Nomad桥中，这个函数负责执行跨链消息。这个函数的安全性至关重要。桥中的每条消息都通过这个函数流动。它不仅必须接受有效消息，还必须拒绝无效消息。它还必须阻止“重放”攻击，即有效消息被重复发送和使用。

在process中，我们可以看到acceptableRoot函数是主要负责检查消息是否有效（“证明”）的函数。acceptableRoot函数通过内部数据库检查消息是否有效。该数据库本质上是使用Merkle树存储的，并且树由离线更新器通过函数update和prove来更新新消息。

再来看acceptableRoot函数：

```
/**
 * @notice Check that the root has been submitted
 * and that the optimistic timeout period has expired,
 * meaning the root can be processed
 * @param _root the Merkle root, submitted in an update, to check
 * @return TRUE iff root has been submitted & timeout has expired
 */
function acceptableRoot(bytes32 _root) public view returns (bool) {
    // this is backwards-compatibility for messages proven/processed
    // under previous versions
    if (_root == LEGACY_STATUS_PROVEN) return true;
    if (_root == LEGACY_STATUS_PROCESSED) return false;

    uint256 _time = confirmAt[_root];
    if (_time == 0) {
        return false;
    }
    return block.timestamp >= _time;
}
```

当_root为0时，应该是没有确认过的，confirmAt的值应该也为0，最后会返回false。但是函数却会返回True，问题出在初始化函数上：

```
function initialize(
    uint32 _remoteDomain,
    address _updater,
    bytes32 _committedRoot,
    uint256 _optimisticSeconds
) public initializer {
    __NomadBase_initialize(_updater);
    // set storage variables
    entered = 1;
    remoteDomain = _remoteDomain;
    committedRoot = _committedRoot;
    // pre-approve the committed root.
    if (_committedRoot != bytes32(0)) confirmAt[_committedRoot] = 1;
    _setOptimisticTimeout(_optimisticSeconds);
}
```
始化函数initialize会将confirmAt的值初始化为1，我们查看了owner账户以及其所有的交易，发现是在初始化时将confirmAt[0]设置成了1。  
![](https://img.learnblockchain.cn/attachments/2022/08/8Oq7y4fP62e937832047e.png)
owner: 0xa5bd5c661f373256c0ccfbc628fd52de74f9bb55
txHash: 0x53fd92771d2084a9bf39a6477015ef53b7f116c79d98a21be723d06d79024cad

之所以会发生这种事情是因为升级后的合约的process函数变了但是初始化函数没变（升级前的合约）：
![](https://img.learnblockchain.cn/attachments/2022/08/mCnOitqE62e9378995b45.png)

原先正常的合约因此产生了漏洞，虽然设置confirmAt[0]为1也挺难以理解的，导致任何消息都能通过梅克尔树的检查，只要想都能无限制地提钱...

## 相关信息
被攻击合约（代理合约）: 0x5d94309e5a0090b165fa4181519701637b6daeba
代理合约实现合约: 0xb92336759618f55bd0f8313bd843604592e27bd8

## 参考资料
<https://www.freebuf.com/articles/blockchain-articles/340882.html>
