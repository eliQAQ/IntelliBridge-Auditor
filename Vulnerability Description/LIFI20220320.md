​### **    漏洞合约函数**

```
function swapAndStartBridgeTokensViaCBridge(
        LiFiData memory _lifiData,
        LibSwap.SwapData[] calldata _swapData,
        CBridgeData calldata _cBridgeData
    ) public payable {
        uint256 _fromTokenBalance = LibAsset.getOwnBalance(_cBridgeData.token);

        LibAsset.transferFromERC20(_cBridgeData.token, msg.sender, address(this), _cBridgeData.amount);

        // Swap
        for (uint8 i; i < _swapData.length; i++) {
            LibSwap.swap(_lifiData.transactionId, _swapData[i]);
        }
        require(
            LibAsset.getOwnBalance(_cBridgeData.token) - _fromTokenBalance == _cBridgeData.amount,
            "ERR_INVALID_AMOUNT"
        );

        _startBridge(_cBridgeData);

        emit LiFiTransferStarted(
            _lifiData.transactionId,
            _lifiData.integrator,
            _lifiData.referrer,
            _lifiData.sendingAssetId,
            _lifiData.receivingAssetId,
            _lifiData.receiver,
            _lifiData.amount,
            _lifiData.destinationChainId,
            block.timestamp
        );
    }
```

![](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw== "点击并拖拽以移动")

```
function swap(bytes32 transactionId, SwapData calldata _swapData) internal {
        uint256 fromAmount = _swapData.fromAmount;
        uint256 toAmount = LibAsset.getOwnBalance(_swapData.receivingAssetId);
        address fromAssetId = _swapData.sendingAssetId;
        if (!LibAsset.isNativeAsset(fromAssetId) && LibAsset.getOwnBalance(fromAssetId) < fromAmount) {
            LibAsset.transferFromERC20(_swapData.sendingAssetId, msg.sender, address(this), fromAmount);
        }

        if (!LibAsset.isNativeAsset(fromAssetId)) {
            LibAsset.approveERC20(IERC20(fromAssetId), _swapData.approveTo, fromAmount);
        }

        // solhint-disable-next-line avoid-low-level-calls
        (bool success, bytes memory res) = _swapData.callTo.call{ value: msg.value }(_swapData.callData);
        if (!success) {
            string memory reason = LibUtil.getRevertMsg(res);
            revert(reason);
        }

        toAmount = LibAsset.getOwnBalance(_swapData.receivingAssetId) - toAmount;
        emit AssetSwapped(
            transactionId,
            _swapData.callTo,
            _swapData.sendingAssetId,
            _swapData.receivingAssetId,
            fromAmount,
            toAmount,
            block.timestamp
        );
    }
```

![](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw== "点击并拖拽以移动")

### **相关交易与地址**

**​攻击者地址:​**[https://etherscan.io/address/0xc6f2bde06967e04caaf4bf4e43717c3342680d76](https://etherscan.io/address/0xc6f2bde06967e04caaf4bf4e43717c3342680d76 "https://etherscan.io/address/0xc6f2bde06967e04caaf4bf4e43717c3342680d76")

**​漏洞合约地址:​**[https://etherscan.io/address/0x73a499e043b03fc047189ab1ba72eb595ff1fc8e#code](https://etherscan.io/address/0x73a499e043b03fc047189ab1ba72eb595ff1fc8e#code "https://etherscan.io/address/0x73a499e043b03fc047189ab1ba72eb595ff1fc8e#code")

**执行的恶意交易：**

![](https://i-blog.csdnimg.cn/direct/65146eb5dad047ee9d3bf152fc431245.png)![](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw== "点击并拖拽以移动")​**编辑**

**具体细节分析**

LIFI 的链下系统会计算最佳的跨链代币交换路径，涉及多次中间币种的兑换。但在链上执行过程中，没有对这些中间交换的数据进行验证。同时用户授权了合约无限额度的代币使用权限，攻击者即可据此构造恶意的交易请求。具体来说，攻击者可以在正常的跨链代币交换数据中混入无关的恶意交易指令（\_swapData）。通过调用 swapAndStartBridgeTokensViaCBridge 函数，攻击者只需发起少量代币的跨链，便能利用混入的恶意交易数据实现其最终目的。

攻击产生的事件：

太多了...

![](https://i-blog.csdnimg.cn/direct/e6621eb0cb2742d981013718a352837d.png)![](data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw== "点击并拖拽以移动")​**编辑**

### **参考链接**

[https://etherscan.io/](https://etherscan.io/ "https://etherscan.io/")

​

