漏洞点在于AnySwapV4Router合约中的anySwapOutUnderlyingWithPermit函数：
```
function anySwapOutUnderlyingWithPermit(
    address from,
    address token,
    address to,
    uint amount,
    uint deadline,
    uint8 v,
    bytes32 r,
    bytes32 s,
    uint toChainID
) external {
    address _underlying = AnyswapV1ERC20(token).underlying();
    IERC20(_underlying).permit(from, address(this), amount, deadline, v, r, s);
    TransferHelper.safeTransferFrom(_underlying, from, token, amount);
    AnyswapV1ERC20(token).depositVault(amount, from);
    _anySwapOut(from, token, to, amount, toChainID);
}
```
AnyswapV1ERC20如下：
```
interface AnyswapV1ERC20 {
    function mint(address to, uint256 amount) external returns (bool);
    function burn(address from, uint256 amount) external returns (bool);
    function changeVault(address newVault) external returns (bool);
    function depositVault(uint amount, address to) external returns (uint);
    function withdrawVault(address from, uint amount, address to) external returns (uint);
    function underlying() external view returns (address);
    function deposit(uint amount, address to) external returns (uint);
    function withdraw(uint amount, address to) external returns (uint);
}
```

这里面除了正常的ERC20接口外，还增加了一些诸如underlying和changeVault等函数。其中underlying代表的是用户在这一条链上的标的资产token合约地址，而permit函数则是通过ECRECOVER签名函数来允许用户的token被代理合约使用（类似于approve）：

```
function permit(address target, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external override {
    require(block.timestamp <= deadline, "AnyswapV3ERC20: Expired permit");

    bytes32 hashStruct = keccak256(
        abi.encode(
            PERMIT_TYPEHASH,
            target,
            spender,
            value,
            nonces[target]++,
            deadline));

    require(verifyEIP712(target, hashStruct, v, r, s) || verifyPersonalSign(target, hashStruct, v, r, s));

    // _approve(owner, spender, value);
    allowance[target][spender] = value;
    emit Approval(target, spender, value);
}
...

function verifyEIP712(address target, bytes32 hashStruct, uint8 v, bytes32 r, bytes32 s) internal view returns (bool) {
    bytes32 hash = keccak256(
        abi.encodePacked(
            "\x19\x01",
            DOMAIN_SEPARATOR,
            hashStruct));
    address signer = ecrecover(hash, v, r, s);
    return (signer != address(0) && signer == target);
}

function verifyPersonalSign(address target, bytes32 hashStruct, uint8 v, bytes32 r, bytes32 s) internal pure returns (bool) {
    bytes32 hash = prefixed(hashStruct);
    address signer = ecrecover(hash, v, r, s);
    return (signer != address(0) && signer == target);
}

// Builds a prefixed hash to mimic the behavior of eth_sign.
function prefixed(bytes32 hash) internal pure returns (bytes32) {
    return keccak256(abi.encodePacked("\x19Ethereum Signed Message:\n32", hash));
}
```
ecrecover函数是由以太坊提供的一个全局函数，用于签名数据的校验。这个函数返回的是签名者的公匙地址。如果返回结果是签名者的公匙地址，那么说明数据是正确的。

depositVault函数用于铸币，生成中间代币：
```
function depositVault(uint amount, address to) external onlyVault returns (uint) {
    return _deposit(amount, to);
}

function _deposit(uint amount, address to) internal returns (uint) {
    require(underlying != address(0x0) && underlying != address(this));
    _mint(to, amount);
    return amount;
}
```
最后的_anySwapOut函数逻辑如下：
```
 function _anySwapOut(address from, address token, address to, uint amount, uint toChainID) internal {
    AnyswapV1ERC20(token).burn(from, amount);
    emit LogAnySwapOut(token, from, to, amount, cID(), toChainID);
}
```

综上所述，这个函数的逻辑就显而易见了，首先会根据传入的token地址找到用户的标的资产，然后使用用户的签名调用permit函数获得这笔资产的代理使用权，将其转换成中间代币，销毁代币，最后发送事件。

以上的逻辑看似没问题，但是这个函数缺少了一个关键的校验，那就是传入的token地址没有验证其是否真的是AnySwapERC类型的token合约地址，由于underlying等后续验证都是站在token这一地址的合法性上，所以如果攻击者利用这一点，就完全可以绕过permit的逻辑转移资产。

设想如下场景：用户A将自己的一部分WETH授权（approve）给了AnySwapRouter合约。攻击者构造了一个恶意的ERC20Token tokenX，将underlying地址设置为了WETH的合约地址。此时，攻击者调用anySwapOutUnderlyingWithPermit， 将from参数设置为用户A的地址，token设置为布置的恶意token地址tokenX，amount设置为用户A的余额，其余参数随便填。那么此时函数执行，会把WETH作为underlying，调用permit函数验证用户交易签名。但是WETH并没有实现permit函数，就会调用fallback，但是漏洞函数中并没有检查其返回值，fallback函数同样也没有返回值，正常执行，此时permit就被完全掠过。接下来，函数就会将用户A授权给router合约的WETH转入攻击者构造的恶意token地址中。攻击者就达成了他邪恶的目的。

__该漏洞是在Anyswap合约与underlying token合约的共同作用下产生，攻击者构造underlying token合约，不存在permit方法实现，且存在有fallback函数，当调用它的permit方法时因为没有实现permit函数，就会调用fallback，但漏洞函数中并没有检查其返回值，会执行通过，从而后续与资金相关的操作得到执行。__


与攻击的有三个地址，分别为ME1，ME2，ME3

ME1为普通账户地址：

<https://etherscan.io/address/0x4986e9017ea60e7afcd10d844f85c80912c3863c>

ME2为攻击合约地址：

<https://etherscan.io/address/0x7e015972db493d9ba9a30075e397dc57b1a677da>

ME3为伪造的恶意token地址：

<https://etherscan.io/address/0xb4f89d6a8c113b4232485568e542e646d93cfab1>

參考交易: 

https://etherscan.io/tx/0xd07c0f40eec44f7674dddf617cbdec4758f258b531e99b18b8ee3b3b95885e7d



## 攻击流程总结

第一步：攻击者选择要攻击的token的地址。

第二步：查询将目标token委托给router合约的用户。

第三步：通过漏洞函数，将受害用户的token转移到伪造token的账户名下。

第四部：将token转移到攻击者账户，返回第一步，寻找新的token和受害者。

## 参考资料
<https://s3cunda.github.io/2022/01/27/multichain-%E5%8E%9Fanyswap-2022.1.18%E6%94%BB%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%88%86%E6%9E%90.html>