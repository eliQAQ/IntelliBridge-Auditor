本次攻击涉及的具体地址：
![](https://image.3001.net/images/20210812/1628739200_6114968097812cc7ca00c.png!small)

## 攻击核心
1、源链未对发起的跨链操作的数据进行检查。  
2、目标链未对解析出的目标调用合约以及调用参数进行检查。  
3、EthCrossChainData 合约的 owner 为 EthCrossChainManager。  
4、 bytes4(keccak256(abi.encodePacked(_method, "(bytes,bytes,uint64)"))) 可以被 hash 碰撞。

## 攻击流程
1、攻击者在源链精心构造一笔修改目标链 Keeper 的操作。  
2、利用官方 Relayer 正常在目标链提交数据并执行替换 Keeper 操作。  
3、攻击者通过替换后的 Keeper 地址对其转出资产的操作进行签名提交至 EthCrossChainManager 进行验证。  
4、验证 Keeper 为攻击者已替换完的地址通过检查，执行将资产转移至攻击者指定地址。  
5、获利走人。

## 攻击细节
EthCrossChainManager 合约用于验证 Poly Chain 同步来的区块头以确认跨链信息的真实。EthCrossChainData 合约用于存储跨链数据，中继链验证人 (即 Keeper) 的公钥也存储在这个合约中。LockProxy 则用于资产管理。

本次攻击中，攻击者分两步来完成这次攻击，我们接下来进行详细分析：  
首先攻击者通过在其他链调用 crossChain 函数构造数据发起跨链交易。
```
function crossChain(uint64 toChainId, bytes calldata toContract, bytes calldata method, bytes calldata txData) whenNotPaused external returns (bool) {
    // Load Ethereum cross chain data contract
    IEthCrossChainData eccd = IEthCrossChainData(EthCrossChainDataAddress);
    
    // To help differentiate two txs, the ethTxHashIndex is increasing automatically
    uint256 txHashIndex = eccd.getEthTxHashIndex();
    
    // Convert the uint256 into bytes
    bytes memory paramTxHash = Utils.uint256ToBytes(txHashIndex);
    
    // Construct the makeTxParam, and put the hash info storage, to help provide proof of tx existence
    bytes memory rawParam = abi.encodePacked(ZeroCopySink.WriteVarBytes(paramTxHash),
        ZeroCopySink.WriteVarBytes(abi.encodePacked(sha256(abi.encodePacked(address(this), paramTxHash)))),
        ZeroCopySink.WriteVarBytes(Utils.addressToBytes(msg.sender)),
        ZeroCopySink.WriteUint64(toChainId),
        ZeroCopySink.WriteVarBytes(toContract),
        ZeroCopySink.WriteVarBytes(method),
        ZeroCopySink.WriteVarBytes(txData)
    );
    
    // Must save it in the storage to be included in the proof to be verified.
    require(eccd.putEthTxHash(keccak256(rawParam)), "Save ethTxHash by index to Data contract failed!");
    
    // Fire the cross chain event denoting there is a cross chain request from Ethereum network to other public chains through Poly chain network
    emit CrossChainEvent(tx.origin, paramTxHash, msg.sender, toChainId, toContract, rawParam);
    return true;
}
```

此函数只是用于帮助用户构造 makeTxParam 并存储了构造后的哈希以便后续验证，其并未对用户传入的跨链操作参数进行任何限制，因此攻击者完全可以通过构造任意想构造的数据而让 Relayer 毫无防备的将其同步至 Poly Chain，通过 Poly Chain 将其同步至以太坊 Relayer。

随后在以太坊上的 Relayer 通过调用 EthCrossChainManager 合约中的 verifyHeaderAndExecuteTx 函数提交区块头信息来验证这笔跨链信息的真实性。
```
function verifyHeaderAndExecuteTx(bytes memory proof, bytes memory rawHeader, bytes memory headerProof, bytes memory curRawHeader,bytes memory headerSig) whenNotPaused public returns (bool){
    ECCUtils.Header memory header = ECCUtils.deserializeHeader(rawHeader);
    // Load ehereum cross chain data contract
    IEthCrossChainData eccd = IEthCrossChainData(EthCrossChainDataAddress);
    
    // Get stored consensus public key bytes of current poly chain epoch and deserialize Poly chain consensus public key bytes to address[]
    address[] memory polyChainBKs = ECCUtils.deserializeKeepers(eccd.getCurEpochConPubKeyBytes());

    uint256 curEpochStartHeight = eccd.getCurEpochStartHeight();

    uint n = polyChainBKs.length;
    if (header.height >= curEpochStartHeight) {
        // It's enough to verify rawHeader signature
        require(ECCUtils.verifySig(rawHeader, headerSig, polyChainBKs, n - ( n - 1) / 3), "Verify poly chain header signature failed!");
    } else {
        // We need to verify the signature of curHeader 
        require(ECCUtils.verifySig(curRawHeader, headerSig, polyChainBKs, n - ( n - 1) / 3), "Verify poly chain current epoch header signature failed!");

        // Then use curHeader.StateRoot and headerProof to verify rawHeader.CrossStateRoot
        ECCUtils.Header memory curHeader = ECCUtils.deserializeHeader(curRawHeader);
        bytes memory proveValue = ECCUtils.merkleProve(headerProof, curHeader.blockRoot);
        require(ECCUtils.getHeaderHash(rawHeader) == Utils.bytesToBytes32(proveValue), "verify header proof failed!");
    }
    
    // Through rawHeader.CrossStatesRoot, the toMerkleValue or cross chain msg can be verified and parsed from proof
    bytes memory toMerkleValueBs = ECCUtils.merkleProve(proof, header.crossStatesRoot);
    
    // Parse the toMerkleValue struct and make sure the tx has not been processed, then mark this tx as processed
    ECCUtils.ToMerkleValue memory toMerkleValue = ECCUtils.deserializeMerkleValue(toMerkleValueBs);
    require(!eccd.checkIfFromChainTxExist(toMerkleValue.fromChainID, Utils.bytesToBytes32(toMerkleValue.txHash)), "the transaction has been executed!");
    require(eccd.markFromChainTxExist(toMerkleValue.fromChainID, Utils.bytesToBytes32(toMerkleValue.txHash)), "Save crosschain tx exist failed!");
    
    // Ethereum ChainId is 2, we need to check the transaction is for Ethereum network
    require(toMerkleValue.makeTxParam.toChainId == uint64(2), "This Tx is not aiming at Ethereum network!");
    
    // Obtain the targeting contract, so that Ethereum cross chain manager contract can trigger the executation of cross chain tx on Ethereum side
    address toContract = Utils.bytesToAddress(toMerkleValue.makeTxParam.toContract);
    
    //TODO: check this part to make sure we commit the next line when doing local net UT test
    require(_executeCrossChainTx(toContract, toMerkleValue.makeTxParam.method, toMerkleValue.makeTxParam.args, toMerkleValue.makeTxParam.fromContract, toMerkleValue.fromChainID), "Execute CrossChain Tx failed!");

    // Fire the cross chain event denoting the executation of cross chain tx is successful,
    // and this tx is coming from other public chains to current Ethereum network
    emit VerifyHeaderAndExecuteTxEvent(toMerkleValue.fromChainID, toMerkleValue.makeTxParam.toContract, toMerkleValue.txHash, toMerkleValue.makeTxParam.txHash);

    return true;
}
```

我们可以看出其先对区块头进行反序列化，以解出所需要验证的具体信息。随后调用 getCurEpochConPubKeyBytes 函数从 EthCrossChainData 合约中获取 Keeper 公钥，并通过 deserializeKeepers 函数得到 Keeper 地址。

接下来将通过 ECCUtils.verifySig 验证签名是否为 Keeper，从以下代码中我们可以发现 verifySig 函数中会切出签名者的 v r s，并通过 ecrecover 接口获取签名者地址，然后调用 containMAddresses 函数循环比较签名者是否为 Keeper，只要 Keeper 签名数量符合要求即可通过检查，数量要求即为 EthCrossChainManager 合约传入的 n - ( n - 1) / 3。
```
function verifySig(bytes memory _rawHeader, bytes memory _sigList, address[] memory _keepers, uint _m) internal pure returns (bool){
    bytes32 hash = getHeaderHash(_rawHeader);

    uint signed = 0;
    uint sigCount = _sigList.length / POLYCHAIN_SIGNATURE_LEN;
    address[] memory signers = new address[](sigCount);
    bytes32 r;
    bytes32 s;
    uint8 v;
    for(uint j = 0; j  < sigCount; j++){
        r = Utils.bytesToBytes32(Utils.slice(_sigList, j*POLYCHAIN_SIGNATURE_LEN, 32));
        s =  Utils.bytesToBytes32(Utils.slice(_sigList, j*POLYCHAIN_SIGNATURE_LEN + 32, 32));
        v =  uint8(_sigList[j*POLYCHAIN_SIGNATURE_LEN + 64]) + 27;
        signers[j] =  ecrecover(sha256(abi.encodePacked(hash)), v, r, s);
    }
    return Utils.containMAddresses(_keepers, signers, _m);
}
```

签名验证后会通过 ECCUtils.merkleProve 进行默克尔根验证，只要是正常跨链操作即可通过此项检查。随后会对交易是否重复发送进行检查并存储已验证后的数据。这里只需保证不重复提交即可。

```
// Through rawHeader.CrossStatesRoot, the toMerkleValue or cross chain msg can be verified and parsed from proof
bytes memory toMerkleValueBs = ECCUtils.merkleProve(proof, header.crossStatesRoot);

// Parse the toMerkleValue struct and make sure the tx has not been processed, then mark this tx as processed
ECCUtils.ToMerkleValue memory toMerkleValue = ECCUtils.deserializeMerkleValue(toMerkleValueBs);
require(!eccd.checkIfFromChainTxExist(toMerkleValue.fromChainID, Utils.bytesToBytes32(toMerkleValue.txHash)), "the transaction has been executed!");
require(eccd.markFromChainTxExist(toMerkleValue.fromChainID, Utils.bytesToBytes32(toMerkleValue.txHash)), "Save crosschain tx exist failed!");
```

最后，也是最关键的一步，其将通过内部调用_executeCrossChainTx 函数执行构造的数据。

```
function _executeCrossChainTx(address _toContract, bytes memory _method, bytes memory _args, bytes memory _fromContractAddr, uint64 _fromChainId) internal returns (bool){
    // Ensure the targeting contract gonna be invoked is indeed a contract rather than a normal account address
    require(Utils.isContract(_toContract), "The passed in address is not a contract!");
    bytes memory returnData;
    bool success;
    
    // The returnData will be bytes32, the last byte must be 01;
    (success, returnData) = _toContract.call(abi.encodePacked(bytes4(keccak256(abi.encodePacked(_method, "(bytes,bytes,uint64)"))), abi.encode(_args, _fromContractAddr, _fromChainId)));
    
    // Ensure the executation is successful
    require(success == true, "EthCrossChain call business contract failed");
    
    // Ensure the returned value is true
    require(returnData.length != 0, "No return value from business contract!");
    (bool res,) = ZeroCopySource.NextBool(returnData, 31);
    require(res == true, "EthCrossChain call business contract return is not true");
    
    return true;
}
```

我们可以看出_executeCrossChainTx 函数未对传入的_toContract、_method 等参数进行检查就直接以_toContract.call 的方式执行交易。

我们可以看出 EthCrossChainData 合约的 owner 即为 EthCrossChainManager 合约，而先前我们知道中继链验证人 (即 Keeper) 的公钥存在 EthCrossChainData 合约中，且此合约存在 putCurEpochConPubKeyBytes 函数可以直接修改 Keeper 公钥。

```
interface IEthCrossChainData {
    function putCurEpochStartHeight(uint32 curEpochStartHeight) external returns (bool);
    function getCurEpochStartHeight() external view returns (uint32);
    function putCurEpochConPubKeyBytes(bytes calldata curEpochPkBytes) external returns (bool);
    function getCurEpochConPubKeyBytes() external view returns (bytes memory);
    function markFromChainTxExist(uint64 fromChainId, bytes32 fromChainTx) external returns (bool);
    function checkIfFromChainTxExist(uint64 fromChainId, bytes32 fromChainTx) external view returns (bool);
    function getEthTxHashIndex() external view returns (uint256);
    function putEthTxHash(bytes32 ethTxHash) external returns (bool);
    function putExtraData(bytes32 key1, bytes32 key2, bytes calldata value) external returns (bool);
    function getExtraData(bytes32 key1, bytes32 key2) external view returns (bytes memory);
    function transferOwnership(address newOwner) external;
    function pause() external returns (bool);
    function unpause() external returns (bool);
    function paused() external view returns (bool);
    // Not used currently by ECCM
    function getEthTxHash(uint256 ethTxHashIndex) external view returns (bytes32);
}
```

攻击者只需在其他链通过 crossChain 正常发起跨链操作的交易，此交易目的是为了调用 EthCrossChainData 合约的 putCurEpochConPubKeyBytes 函数以修改 Keeper 角色。随后通过正常的跨链流程，Keeper 会解析用户请求的目标合约以及调用参数，构造出一个新的交易提交到以太坊上。这本质上也只是一笔正常的跨链操作，因此可以直接通过 Keeper 检查与默克尔根检查。最后成功执行修改 Keeper（4个） 的操作。

但我们注意到 putCurEpochConPubKeyBytes 函数定义为

```
function putCurEpochConPubKeyBytes(bytes calldata curEpochPkBytes) external returns (bool);
```

而_executeCrossChainTx 函数执行的定义为
```
abi.encodePacked(bytes4(keccak256(abi.encodePacked(_method, "(bytes,bytes,uint64)")))
```

这两个函数的函数签名在正常情况下传入的_method 与 putCurEpochConPubKeyBytes 肯定是完全不同的，因此通过_toContract.call 理论上是无法调用到 putCurEpochConPubKeyBytes 函数的。但_method 是攻击者可以控制的，其完全可以通过枚举各个字符组合以获得与调用 putCurEpochConPubKeyBytes 函数相同的函数签名，这要求其只需枚举前 4 个字节符合即可:
![](https://image.3001.net/images/20210812/1628739343_6114970fd2d6d169d1799.png!small)

最后攻击者只需使用替换后的 Keeper 地址进行签名即可通过所有检查, 执行调用 LockProxy 合约的 unlock 函数，将其管理的资产转出。

好高端啊...

## 注意
1. 源链未对上链的交易做语义校验，因此因此包含修改keeper恶意交易可以被打包到poly chain上
2. 目标链上relayer虽然对交易做了校验，但是攻击者可以直接调用以太坊上的EthCrossChainManager合约最终调用EthCrossChainData合约完成签名修改（直接使用已经打包好的区块数据将payload发送到以太坊EthCrossChainManager合约并执行，这个过程中，可以通过merkle proof的校验，因为是已经正常上链的poly chain区块数据）

## 参考资料
<https://www.freebuf.com/vuls/284340.html>  
<https://zhuanlan.zhihu.com/p/398941126>
