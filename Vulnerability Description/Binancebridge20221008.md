## 漏洞分析

![Merkle 树](https://miro.medium.com/v2/resize:fit:1100/format:webp/0*I5ggJLeE9RAAsvYV)
Merkle 树是一种结构，可以在不泄露整个数据库内容的情况下验证某条数据是否存在。其原理是通过哈希数据并与根哈希（root hash）进行比对。

每个节点的数据是其子节点数据拼接后再哈希得出的。如果是叶子节点，则其值就是底层数据的哈希。例如：

P1 = h(P3, P4)

P3 = h(data)

验证某个数据是否在树中，需要知道该数据节点到根节点之间路径上的兄弟节点（path node），这些就是我们所说的 Merkle 证明。

关键点在于拼接顺序非常重要，哪怕一个字符的差异，也会导致完全不同的哈希结果。

通常情况下，拼接顺序由子节点的哈希值大小决定，例如如果 P3 > P4，则拼接顺序为 (P3, P4)，否则为 (P4, P3)。

![IAVL](https://miro.medium.com/v2/resize:fit:1100/format:webp/0*_jLAeCSrcWwmGGkA)
IAVL 使用了一种不同的方式：通过路径节点增加 左（left） 和 右（right） 属性来指明当前节点是左子节点还是右子节点。例如：

如果某个路径节点 lpath 设置了 right = P4，则说明我们需要将另一个节点拼在 P4 的左边，再哈希得到上层节点。

漏洞出现在验证时并未使用 right 属性来参与根哈希的计算。
由于 proof 是用户可以控制的，攻击者可以构造恶意的 right 属性（即其恶意 payload 的哈希），使得验证通过：

```
if !bytes.Equal(derivedRoot, lpath.Right) {
    return nil, treeEnd, false, cmn.ErrorWrap(ErrInvalidRoot, "intermediate root hash %X doesn't match, got %X", lpath.Right, derivedRoot)
}
```

## 攻击流程

安全研究员 Emiliano Bonassi 曾在推文中指出，攻击者复用了 历史上第一笔跨链交易 的证明数据，并基于此修改构造了一个新的恶意证明。

攻击者的步骤如下：

获取一笔合法交易的证明数据

对其进行解码（unmarshal），以便修改结构体字段

打印原始合法的 rangeProof

哈希构造出的恶意 payload

构造 package 序列

向证明中添加新的叶子节点（对应恶意 payload）

添加空的内部节点以通过验证结构要求

将恶意叶子节点的哈希作为 right 属性加入到路径节点中

最后将构造的恶意 proof 重新序列化

使用验证函数验证其合法性

如果合法和恶意 proof 计算出的根哈希一致，且验证函数无报错，则说明 PoC 成功。

示例验证输出：

```
LEGIT ROOT HASH = e09159530585455058cf1785f411ea44230f39334e6e0f6a3c54dbf069df2b62  
EVIL ROOT HASH = e09159530585455058cf1785f411ea44230f39334e6e0f6a3c54dbf069df2b62  
error computing root hash? <nil>  
error verifying proof? <nil>

```

攻击函数为 handlePackage()，仅允许 relayer 调用。攻击者先往 relayer 合约存入 100 BNB 成为合法 relayer，然后执行攻击。

由于 Binance 已更新链上合约，无法通过 fork 主网复现该漏洞。但可以在本地环境构造恶意 payload，通过 IAVL 的 verify() 函数确认攻击有效性。

攻击者通过调用 craftPayload() 构造恶意交易的载荷（参数包括 token 地址、数量、接收地址、过期时间），如需转出原生币 BNB，可传入 address(0)。

## 参考链接

https://medium.com/immunefi/hack-analysis-binance-bridge-october-2022-2876d39247c1