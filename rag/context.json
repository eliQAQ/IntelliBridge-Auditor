{
    "event": "AssetSwapped",
    "call_graph": "swap",
    "context": {
        "NATIVE_ASSETID": "address internal constant NATIVE_ASSETID = NULL_ADDRESS;",
        "NULL_ADDRESS": "address internal constant NULL_ADDRESS = address(0);"
    },
    "code": [
        "LibSwap.swap:function swap(bytes32 transactionId, SwapData calldata _swap) internal { if (!LibAsset.isContract(_swap.callTo)) revert InvalidContract(); uint256 fromAmount = _swap.fromAmount; if (fromAmount == 0) revert NoSwapFromZeroBalance(); uint256 nativeValue = LibAsset.isNativeAsset(_swap.sendingAssetId) ? _swap.fromAmount : 0; uint256 initialSendingAssetBalance = LibAsset.getOwnBalance( _swap.sendingAssetId ); uint256 initialReceivingAssetBalance = LibAsset.getOwnBalance( _swap.receivingAssetId ); if (nativeValue == 0) { LibAsset.maxApproveERC20( IERC20(_swap.sendingAssetId), _swap.approveTo, _swap.fromAmount ); } if (initialSendingAssetBalance < _swap.fromAmount) { revert InsufficientBalance( _swap.fromAmount, initialSendingAssetBalance ); } (bool success, bytes memory res) = _swap.callTo.call{ value: nativeValue }(_swap.callData); if (!success) { LibUtil.revertWith(res); } uint256 newBalance = LibAsset.getOwnBalance(_swap.receivingAssetId); emit AssetSwapped( transactionId, _swap.callTo, _swap.sendingAssetId, _swap.receivingAssetId, _swap.fromAmount, newBalance > initialReceivingAssetBalance ? newBalance - initialReceivingAssetBalance : newBalance, block.timestamp ); }",
        "LibAsset.isContract:function isContract(address _contractAddr) internal view returns (bool) { uint256 size; assembly { size := extcodesize(_contractAddr) } return size > 0; }",
        "LibAsset.isNativeAsset:function isNativeAsset(address assetId) internal pure returns (bool) { return assetId == NATIVE_ASSETID; }",
        "LibAsset.getOwnBalance:function getOwnBalance(address assetId) internal view returns (uint256) { return isNativeAsset(assetId) ? address(this).balance : IERC20(assetId).balanceOf(address(this)); }",
        "LibAsset.maxApproveERC20:function maxApproveERC20( IERC20 assetId, address spender, uint256 amount ) internal { if (isNativeAsset(address(assetId))) { return; } if (spender == NULL_ADDRESS) { revert NullAddrIsNotAValidSpender(); } if (assetId.allowance(address(this), spender) < amount) { SafeERC20.safeApprove(IERC20(assetId), spender, 0); SafeERC20.safeApprove(IERC20(assetId), spender, MAX_UINT); } }",
        "LibUtil.revertWith:function revertWith(bytes memory data) internal pure { assembly { let dataSize := mload(data) let dataPtr := add(data, 0x20) revert(dataPtr, dataSize) } }",
        "SafeERC20.safeApprove:function safeApprove(IERC20 token, address spender, uint256 value) internal { require( (value == 0) || (token.allowance(address(this), spender) == 0), \"SafeERC20: approve from non-zero to non-zero allowance\" ); _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value)); }",
        "SafeERC20._callOptionalReturn:function _callOptionalReturn(IERC20 token, bytes memory data) private { bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\"); require(returndata.length == 0 || abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\"); }",
        "Address.functionCall:function functionCall(address target, bytes memory data) internal returns (bytes memory) { return functionCallWithValue(target, data, 0, \"Address: low-level call failed\"); }",
        "Address.functionCallWithValue:function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) { return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\"); }",
        "Address.verifyCallResultFromTarget:function verifyCallResultFromTarget( address target, bool success, bytes memory returndata, string memory errorMessage ) internal view returns (bytes memory) { if (success) { if (returndata.length == 0) { require(isContract(target), \"Address: call to non-contract\"); } return returndata; } else { _revert(returndata, errorMessage); } }",
        "Address.isContract:function isContract(address account) internal view returns (bool) { return account.code.length > 0; }",
        "Address._revert:function _revert(bytes memory returndata, string memory errorMessage) private pure { if (returndata.length > 0) { assembly { let returndata_size := mload(returndata) revert(add(32, returndata), returndata_size) } } else { revert(errorMessage); } }",
        "function isContract(address _contractAddr) internal view returns (bool){ uint256 size; assembly{ size := extcodesize(_contractAddr)} return size > 0;}",
        "function allowance(address owner, address spender) external view returns (uint256);",
        "function functionCall( address target, bytes memory data, string memory errorMessage ) internal returns (bytes memory){ return functionCallWithValue(target, data, 0, errorMessage);}",
        "function functionCallWithValue( address target, bytes memory data, uint256 value, string memory errorMessage ) internal returns (bytes memory){ require(address(this).balance >= value, \"Address: insufficient balance for call\"); (bool success, bytes memory returndata) = target.call{ value: value} (data); return verifyCallResultFromTarget(target, success, returndata, errorMessage);}",
        "function verifyCallResultFromTarget( address target, bool success, bytes memory returndata, string memory errorMessage ) internal view returns (bytes memory){ if (success){ if (returndata.length == 0){ require(isContract(target), \"Address: call to non- contract \");} return returndata;} else{ _revert(returndata, errorMessage);}}"
    ]
}