{
    "event": "AssetSwapped",
    "call_graph": "_depositAndSwap->_executeSwaps->swap",
    "context": {
        "NATIVE_ASSETID": "address internal constant NATIVE_ASSETID = NULL_ADDRESS;",
        "NULL_ADDRESS": "address internal constant NULL_ADDRESS = address(0);"
    },
    "code": [
        "SwapperV2._depositAndSwap:function _depositAndSwap( bytes32 _transactionId, uint256 _minAmount, LibSwap.SwapData[] calldata _swaps, address payable _leftoverReceiver ) internal returns (uint256) { uint256 numSwaps = _swaps.length; if (numSwaps == 0) { revert NoSwapDataProvided(); } address finalTokenId = _swaps[numSwaps - 1].receivingAssetId; uint256 initialBalance = LibAsset.getOwnBalance(finalTokenId); if (LibAsset.isNativeAsset(finalTokenId)) { initialBalance -= msg.value; } uint256[] memory initialBalances = _fetchBalances(_swaps); LibAsset.depositAssets(_swaps); _executeSwaps( _transactionId, _swaps, _leftoverReceiver, initialBalances ); uint256 newBalance = LibAsset.getOwnBalance(finalTokenId) - initialBalance; if (newBalance < _minAmount) { revert CumulativeSlippageTooHigh(_minAmount, newBalance); } return newBalance; }",
        "SwapperV2._executeSwaps:function _executeSwaps( bytes32 _transactionId, LibSwap.SwapData[] calldata _swaps, address payable _leftoverReceiver, uint256[] memory _initialBalances ) internal noLeftovers(_swaps, _leftoverReceiver, _initialBalances) { uint256 numSwaps = _swaps.length; for (uint256 i = 0; i < numSwaps; ) { LibSwap.SwapData calldata currentSwap = _swaps[i]; if ( !((LibAsset.isNativeAsset(currentSwap.sendingAssetId) || LibAllowList.contractIsAllowed(currentSwap.approveTo)) && LibAllowList.contractIsAllowed(currentSwap.callTo) && LibAllowList.selectorIsAllowed( bytes4(currentSwap.callData[:4]) )) ) revert ContractCallNotAllowed(); LibSwap.swap(_transactionId, currentSwap); unchecked { ++i; } } }",
        "LibSwap.swap:function swap(bytes32 transactionId, SwapData calldata _swap) internal { if (!LibAsset.isContract(_swap.callTo)) revert InvalidContract(); uint256 fromAmount = _swap.fromAmount; if (fromAmount == 0) revert NoSwapFromZeroBalance(); uint256 nativeValue = LibAsset.isNativeAsset(_swap.sendingAssetId) ? _swap.fromAmount : 0; uint256 initialSendingAssetBalance = LibAsset.getOwnBalance( _swap.sendingAssetId ); uint256 initialReceivingAssetBalance = LibAsset.getOwnBalance( _swap.receivingAssetId ); if (nativeValue == 0) { LibAsset.maxApproveERC20( IERC20(_swap.sendingAssetId), _swap.approveTo, _swap.fromAmount ); } if (initialSendingAssetBalance < _swap.fromAmount) { revert InsufficientBalance( _swap.fromAmount, initialSendingAssetBalance ); } (bool success, bytes memory res) = _swap.callTo.call{ value: nativeValue }(_swap.callData); if (!success) { LibUtil.revertWith(res); } uint256 newBalance = LibAsset.getOwnBalance(_swap.receivingAssetId); emit AssetSwapped( transactionId, _swap.callTo, _swap.sendingAssetId, _swap.receivingAssetId, _swap.fromAmount, newBalance > initialReceivingAssetBalance ? newBalance - initialReceivingAssetBalance : newBalance, block.timestamp ); }",
        "LibAsset.isContract:function isContract(address _contractAddr) internal view returns (bool) { uint256 size; assembly { size := extcodesize(_contractAddr) } return size > 0; }",
        "LibAsset.isNativeAsset:function isNativeAsset(address assetId) internal pure returns (bool) { return assetId == NATIVE_ASSETID; }",
        "LibAsset.getOwnBalance:function getOwnBalance(address assetId) internal view returns (uint256) { return isNativeAsset(assetId) ? address(this).balance : IERC20(assetId).balanceOf(address(this)); }",
        "LibAsset.maxApproveERC20:function maxApproveERC20( IERC20 assetId, address spender, uint256 amount ) internal { if (isNativeAsset(address(assetId))) { return; } if (spender == NULL_ADDRESS) { revert NullAddrIsNotAValidSpender(); } if (assetId.allowance(address(this), spender) < amount) { SafeERC20.safeApprove(IERC20(assetId), spender, 0); SafeERC20.safeApprove(IERC20(assetId), spender, MAX_UINT); } }",
        "LibUtil.revertWith:function revertWith(bytes memory data) internal pure { assembly { let dataSize := mload(data) let dataPtr := add(data, 0x20) revert(dataPtr, dataSize) } }",
        "LibAsset.getOwnBalance:function getOwnBalance(address assetId) internal view returns (uint256) { return isNativeAsset(assetId) ? address(this).balance : IERC20(assetId).balanceOf(address(this)); }",
        "LibAsset.isNativeAsset:function isNativeAsset(address assetId) internal pure returns (bool) { return assetId == NATIVE_ASSETID; }",
        "SwapperV2._fetchBalances:function _fetchBalances( LibSwap.SwapData[] calldata _swaps ) private view returns (uint256[] memory) { uint256 numSwaps = _swaps.length; uint256[] memory balances = new uint256[](numSwaps); address asset; for (uint256 i = 0; i < numSwaps; ) { asset = _swaps[i].receivingAssetId; balances[i] = LibAsset.getOwnBalance(asset); if (LibAsset.isNativeAsset(asset)) { balances[i] -= msg.value; } unchecked { ++i; } } return balances; }",
        "LibAsset.depositAssets:function depositAssets(LibSwap.SwapData[] calldata swaps) internal { for (uint256 i = 0; i < swaps.length; ) { LibSwap.SwapData calldata swap = swaps[i]; if (swap.requiresDeposit) { depositAsset(swap.sendingAssetId, swap.fromAmount); } unchecked { i++; } } }",
        "LibAsset.isNativeAsset:function isNativeAsset(address assetId) internal pure returns (bool) { return assetId == NATIVE_ASSETID; }",
        "LibAllowList.contractIsAllowed:function contractIsAllowed( address _contract ) internal view returns (bool) { return _getStorage().allowlist[_contract]; }",
        "LibAllowList.selectorIsAllowed:function selectorIsAllowed(bytes4 _selector) internal view returns (bool) { return _getStorage().selectorAllowList[_selector]; }",
        "LibAsset.depositAsset:function depositAsset(address assetId, uint256 amount) internal { if (amount == 0) revert InvalidAmount(); if (isNativeAsset(assetId)) { if (msg.value < amount) revert InvalidAmount(); } else { uint256 balance = IERC20(assetId).balanceOf(msg.sender); if (balance < amount) revert InsufficientBalance(amount, balance); transferFromERC20(assetId, msg.sender, address(this), amount); } }",
        "LibAllowList._getStorage:function _getStorage() internal pure returns (AllowListStorage storage als) { bytes32 position = NAMESPACE; assembly { als.slot := position } }",
        "LibAllowList._getStorage:function _getStorage() internal pure returns (AllowListStorage storage als) { bytes32 position = NAMESPACE; assembly { als.slot := position } }",
        "SafeERC20.safeApprove:function safeApprove(IERC20 token, address spender, uint256 value) internal { require( (value == 0) || (token.allowance(address(this), spender) == 0), \"SafeERC20: approve from non-zero to non-zero allowance\" ); _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value)); }",
        "LibAsset.isNativeAsset:function isNativeAsset(address assetId) internal pure returns (bool) { return assetId == NATIVE_ASSETID; }",
        "LibAsset.transferFromERC20:function transferFromERC20( address assetId, address from, address to, uint256 amount ) internal { if (isNativeAsset(assetId)) { revert NullAddrIsNotAnERC20Token(); } if (to == NULL_ADDRESS) { revert NoTransferToNullAddress(); } IERC20 asset = IERC20(assetId); uint256 prevBalance = asset.balanceOf(to); SafeERC20.safeTransferFrom(asset, from, to, amount); if (asset.balanceOf(to) - prevBalance != amount) { revert InvalidAmount(); } }",
        "SafeERC20._callOptionalReturn:function _callOptionalReturn(IERC20 token, bytes memory data) private { bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\"); require(returndata.length == 0 || abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\"); }",
        "SafeERC20.safeTransferFrom:function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal { _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value)); }",
        "Address.functionCall:function functionCall(address target, bytes memory data) internal returns (bytes memory) { return functionCallWithValue(target, data, 0, \"Address: low-level call failed\"); }",
        "SafeERC20._callOptionalReturn:function _callOptionalReturn(IERC20 token, bytes memory data) private { bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\"); require(returndata.length == 0 || abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\"); }",
        "Address.functionCallWithValue:function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) { return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\"); }",
        "Address.functionCall:function functionCall(address target, bytes memory data) internal returns (bytes memory) { return functionCallWithValue(target, data, 0, \"Address: low-level call failed\"); }",
        "Address.verifyCallResultFromTarget:function verifyCallResultFromTarget( address target, bool success, bytes memory returndata, string memory errorMessage ) internal view returns (bytes memory) { if (success) { if (returndata.length == 0) { require(isContract(target), \"Address: call to non-contract\"); } return returndata; } else { _revert(returndata, errorMessage); } }",
        "Address.functionCallWithValue:function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) { return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\"); }",
        "Address.isContract:function isContract(address account) internal view returns (bool) { return account.code.length > 0; }",
        "Address._revert:function _revert(bytes memory returndata, string memory errorMessage) private pure { if (returndata.length > 0) { assembly { let returndata_size := mload(returndata) revert(add(32, returndata), returndata_size) } } else { revert(errorMessage); } }",
        "Address.verifyCallResultFromTarget:function verifyCallResultFromTarget( address target, bool success, bytes memory returndata, string memory errorMessage ) internal view returns (bytes memory) { if (success) { if (returndata.length == 0) { require(isContract(target), \"Address: call to non-contract\"); } return returndata; } else { _revert(returndata, errorMessage); } }",
        "Address.isContract:function isContract(address account) internal view returns (bool) { return account.code.length > 0; }",
        "Address._revert:function _revert(bytes memory returndata, string memory errorMessage) private pure { if (returndata.length > 0) { assembly { let returndata_size := mload(returndata) revert(add(32, returndata), returndata_size) } } else { revert(errorMessage); } }",
        "function _executeSwaps( ReserveData memory _reserveData, LibSwap.SwapData[] calldata _swaps, uint256[] memory _initialBalances ) internal noLeftoversReserve( _swaps, _reserveData.leftoverReceiver, _initialBalances, _reserveData.nativeReserve ){ uint256 numSwaps = _swaps.length; for (uint256 i = 0; i < numSwaps; ){ LibSwap.SwapData calldata currentSwap = _swaps[i]; if ( !((LibAsset.isNativeAsset(currentSwap.sendingAssetId) || LibAllowList.contractIsAllowed(currentSwap.approveTo)) && LibAllowList.contractIsAllowed(currentSwap.callTo) && LibAllowList.selectorIsAllowed( bytes4(currentSwap.callData[:4]) )) ) revert ContractCallNotAllowed(); LibSwap.swap(_reserveData.transactionId, currentSwap); unchecked{ ++i;}}}",
        "modifier noLeftovers( LibSwap.SwapData[] calldata _swaps, address payable _leftoverReceiver, uint256[] memory _initialBalances ){ uint256 numSwaps = _swaps.length; if (numSwaps != 1){ address finalAsset = _swaps[numSwaps - 1].receivingAssetId; uint256 curBalance; _; for (uint256 i = 0; i < numSwaps - 1; ){ address curAsset = _swaps[i].receivingAssetId; if (curAsset != finalAsset){ curBalance = LibAsset.getOwnBalance(curAsset) - _initialBalances[i]; if (curBalance > 0){ LibAsset.transferAsset( curAsset, _leftoverReceiver, curBalance );}} unchecked{ ++i;}}} else{ _;}}",
        "modifier noLeftoversReserve( LibSwap.SwapData[] calldata _swaps, address payable _leftoverReceiver, uint256[] memory _initialBalances, uint256 _nativeReserve ){ uint256 numSwaps = _swaps.length; if (numSwaps != 1){ address finalAsset = _swaps[numSwaps - 1].receivingAssetId; uint256 curBalance; _; for (uint256 i = 0; i < numSwaps - 1; ){ address curAsset = _swaps[i].receivingAssetId; if (curAsset != finalAsset){ curBalance = LibAsset.getOwnBalance(curAsset) - _initialBalances[i]; uint256 reserve = LibAsset.isNativeAsset(curAsset) ? _nativeReserve : 0; if (curBalance > 0){ LibAsset.transferAsset( curAsset, _leftoverReceiver, curBalance - reserve );}} unchecked{ ++i;}}} else{ _;}}",
        "function allowance(address owner, address spender) external view returns (uint256);",
        "function balanceOf(address account) external view returns (uint256);",
        "function functionCall( address target, bytes memory data, string memory errorMessage ) internal returns (bytes memory){ return functionCallWithValue(target, data, 0, errorMessage);}",
        "function functionCallWithValue( address target, bytes memory data, uint256 value, string memory errorMessage ) internal returns (bytes memory){ require(address(this).balance >= value, \"Address: insufficient balance for call\"); (bool success, bytes memory returndata) = target.call{ value: value} (data); return verifyCallResultFromTarget(target, success, returndata, errorMessage);}"
    ]
}