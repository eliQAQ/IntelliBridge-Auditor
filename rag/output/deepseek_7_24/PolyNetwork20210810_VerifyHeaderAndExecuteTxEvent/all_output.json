{
    "EthCrossChainManager.verifyHeaderAndExecuteTx": {
        "step1": {
            "prompt1": "\nYou are an experienced cross-chain protocol analysis expert. Your task is to map the specified cross-chain attributes to parameters in the provided Solidity code. If an attribute cannot be found in the code, do not list it in the output. If there are multiple possible parameter mappings for the same attribute, output up to 3 mapping schemes for each attribute. Please strictly follow the input and output formats defined below:\nInput format: You will receive a JSON object as input, structured as follows:\n{\n\"attribute\": \n{ \n\"<attribute>\": \"<attribute description>\" ,\n\"<attribute>\": \"<attribute description>\",\n...\n}\n\"code\": \"...\" // Solidity contract code string\n}\n\n\nOutput format:\nReturn a JSON array, each item structured must as follows:\n[ \n{\n\"parameter\": \"...\", // The parameter name in the code most likely corresponding to the attribute\n\"attribute\": \"...\", // The input cross-chain attribute\n\"reason\": \"...\" // Brief explanation: why this parameter was chosen, and possible ambiguities\n}, ... \n]\nIn the reason, please point out both the core basis for the mapping and potential uncertainties (e.g., parameter name similarity, ambiguous contextual meaning, etc.).\n\nInput:\n{\n\"attribute\": {\"sourceChainID\": \"Indicates the originating blockchain network from which the cross-chain transaction is initiated.\", \"toChainID\": \"Indicates the target blockchain network where the transaction is intended to be completed.\", \"amount\": \"The quantity of tokens or assets to be transferred across chains.\", \"nonce\": \"A unique number associated with the transaction to ensure its uniqueness and order.\", \"proof\": \"A cryptographic artifact used to confirm the authenticity of the transaction data from the source chain.\", \"externalCallAddress\": \"The address of a contract to be called after the cross-chain transfer.\", \"externalCallFunction\": \"The specific function or calldata to be executed on the `externalCallAddress`.\"},\n\"code\": [\"EthCrossChainManager.verifyHeaderAndExecuteTx:function verifyHeaderAndExecuteTx(bytes memory proof, bytes memory rawHeader, bytes memory headerProof, bytes memory curRawHeader,bytes memory headerSig) whenNotPaused public returns (bool){\\n        ECCUtils.Header memory header = ECCUtils.deserializeHeader(rawHeader);\\n        // Load ehereum cross chain data contract\\n        IEthCrossChainData eccd = IEthCrossChainData(EthCrossChainDataAddress);\\n        \\n        // Get stored consensus public key bytes of current poly chain epoch and deserialize Poly chain consensus public key bytes to address[]\\n        address[] memory polyChainBKs = ECCUtils.deserializeKeepers(eccd.getCurEpochConPubKeyBytes());\\n\\n        uint256 curEpochStartHeight = eccd.getCurEpochStartHeight();\\n\\n        uint n = polyChainBKs.length;\\n        if (header.height >= curEpochStartHeight) {\\n            // It's enough to verify rawHeader signature\\n            require(ECCUtils.verifySig(rawHeader, headerSig, polyChainBKs, n - ( n - 1) / 3), \\\"Verify poly chain header signature failed!\\\");\\n        } else {\\n            // We need to verify the signature of curHeader \\n            require(ECCUtils.verifySig(curRawHeader, headerSig, polyChainBKs, n - ( n - 1) / 3), \\\"Verify poly chain current epoch header signature failed!\\\");\\n\\n            // Then use curHeader.StateRoot and headerProof to verify rawHeader.CrossStateRoot\\n            ECCUtils.Header memory curHeader = ECCUtils.deserializeHeader(curRawHeader);\\n            bytes memory proveValue = ECCUtils.merkleProve(headerProof, curHeader.blockRoot);\\n            require(ECCUtils.getHeaderHash(rawHeader) == Utils.bytesToBytes32(proveValue), \\\"verify header proof failed!\\\");\\n        }\\n        \\n        // Through rawHeader.CrossStatesRoot, the toMerkleValue or cross chain msg can be verified and parsed from proof\\n        bytes memory toMerkleValueBs = ECCUtils.merkleProve(proof, header.crossStatesRoot);\\n        \\n        // Parse the toMerkleValue struct and make sure the tx has not been processed, then mark this tx as processed\\n        ECCUtils.ToMerkleValue memory toMerkleValue = ECCUtils.deserializeMerkleValue(toMerkleValueBs);\\n        require(!eccd.checkIfFromChainTxExist(toMerkleValue.fromChainID, Utils.bytesToBytes32(toMerkleValue.txHash)), \\\"the transaction has been executed!\\\");\\n        require(eccd.markFromChainTxExist(toMerkleValue.fromChainID, Utils.bytesToBytes32(toMerkleValue.txHash)), \\\"Save crosschain tx exist failed!\\\");\\n        \\n        // Ethereum ChainId is 2, we need to check the transaction is for Ethereum network\\n        require(toMerkleValue.makeTxParam.toChainId == uint64(2), \\\"This Tx is not aiming at Ethereum network!\\\");\\n        \\n        // Obtain the targeting contract, so that Ethereum cross chain manager contract can trigger the executation of cross chain tx on Ethereum side\\n        address toContract = Utils.bytesToAddress(toMerkleValue.makeTxParam.toContract);\\n        \\n        //TODO: check this part to make sure we commit the next line when doing local net UT test\\n        require(_executeCrossChainTx(toContract, toMerkleValue.makeTxParam.method, toMerkleValue.makeTxParam.args, toMerkleValue.makeTxParam.fromContract, toMerkleValue.fromChainID), \\\"Execute CrossChain Tx failed!\\\");\\n\\n        // Fire the cross chain event denoting the executation of cross chain tx is successful,\\n        // and this tx is coming from other public chains to current Ethereum network\\n        emit VerifyHeaderAndExecuteTxEvent(toMerkleValue.fromChainID, toMerkleValue.makeTxParam.toContract, toMerkleValue.txHash, toMerkleValue.makeTxParam.txHash);\\n\\n        return true;\\n    }\", \"ECCUtils.deserializeMerkleValue:function deserializeMerkleValue(bytes memory _valueBs) internal pure returns (ToMerkleValue memory) {\\n        ToMerkleValue memory toMerkleValue;\\n        uint256 off = 0;\\n\\n        (toMerkleValue.txHash, off) = ZeroCopySource.NextVarBytes(_valueBs, off);\\n\\n        (toMerkleValue.fromChainID, off) = ZeroCopySource.NextUint64(_valueBs, off);\\n\\n        TxParam memory txParam;\\n\\n        (txParam.txHash, off) = ZeroCopySource.NextVarBytes(_valueBs, off);\\n        \\n        (txParam.crossChainId, off) = ZeroCopySource.NextVarBytes(_valueBs, off);\\n\\n        (txParam.fromContract, off) = ZeroCopySource.NextVarBytes(_valueBs, off);\\n\\n        (txParam.toChainId, off) = ZeroCopySource.NextUint64(_valueBs, off);\\n\\n        (txParam.toContract, off) = ZeroCopySource.NextVarBytes(_valueBs, off);\\n\\n        (txParam.method, off) = ZeroCopySource.NextVarBytes(_valueBs, off);\\n\\n        (txParam.args, off) = ZeroCopySource.NextVarBytes(_valueBs, off);\\n        toMerkleValue.makeTxParam = txParam;\\n\\n        return toMerkleValue;\\n    }\", \"ECCUtils.deserializeKeepers:function deserializeKeepers(bytes memory keepersBytes) internal pure returns (address[] memory) {\\n        uint256 off = 0;\\n        uint64 keeperLen;\\n        (keeperLen, off) = ZeroCopySource.NextUint64(keepersBytes, off);\\n        address[] memory keepers = new address[](keeperLen);\\n        bytes memory keeperBytes;\\n        for(uint i = 0; i < keeperLen; i++) {\\n            (keeperBytes, off) = ZeroCopySource.NextVarBytes(keepersBytes, off);\\n            keepers[i] = Utils.bytesToAddress(keeperBytes);\\n        }\\n        return keepers;\\n    }\", \"Utils.bytesToBytes32:function bytesToBytes32(bytes memory _bs) internal pure returns (bytes32 value) {\\n        require(_bs.length == 32, \\\"bytes length is not 32.\\\");\\n        assembly {\\n            // load 32 bytes from memory starting from position _bs + 0x20 since the first 0x20 bytes stores _bs length\\n            value := mload(add(_bs, 0x20))\\n        }\\n    }\", \"Utils.bytesToAddress:function bytesToAddress(bytes memory _bs) internal pure returns (address addr)\\n    {\\n        require(_bs.length == 20, \\\"bytes length does not match address\\\");\\n        assembly {\\n            // for _bs, first word store _bs.length, second word store _bs.value\\n            // load 32 bytes from mem[_bs+20], convert it into Uint160, meaning we take last 20 bytes as addr (address).\\n            addr := mload(add(_bs, 0x14))\\n        }\\n\\n    }\", \"ECCUtils.deserializeHeader:function deserializeHeader(bytes memory _headerBs) internal pure returns (Header memory) {\\n        Header memory header;\\n        uint256 off = 0;\\n        (header.version, off)  = ZeroCopySource.NextUint32(_headerBs, off);\\n\\n        (header.chainId, off) = ZeroCopySource.NextUint64(_headerBs, off);\\n\\n        (header.prevBlockHash, off) = ZeroCopySource.NextHash(_headerBs, off);\\n\\n        (header.transactionsRoot, off) = ZeroCopySource.NextHash(_headerBs, off);\\n\\n        (header.crossStatesRoot, off) = ZeroCopySource.NextHash(_headerBs, off);\\n\\n        (header.blockRoot, off) = ZeroCopySource.NextHash(_headerBs, off);\\n\\n        (header.timestamp, off) = ZeroCopySource.NextUint32(_headerBs, off);\\n\\n        (header.height, off) = ZeroCopySource.NextUint32(_headerBs, off);\\n\\n        (header.consensusData, off) = ZeroCopySource.NextUint64(_headerBs, off);\\n\\n        (header.consensusPayload, off) = ZeroCopySource.NextVarBytes(_headerBs, off);\\n\\n        (header.nextBookkeeper, off) = ZeroCopySource.NextBytes20(_headerBs, off);\\n\\n        return header;\\n    }\", \"ECCUtils.getHeaderHash:function getHeaderHash(bytes memory rawHeader) internal pure returns (bytes32) {\\n        return sha256(abi.encodePacked(sha256(rawHeader)));\\n    }\", \"ECCUtils.verifySig:function verifySig(bytes memory _rawHeader, bytes memory _sigList, address[] memory _keepers, uint _m) internal pure returns (bool){\\n        bytes32 hash = getHeaderHash(_rawHeader);\\n\\n        uint signed = 0;\\n        uint sigCount = _sigList.length / POLYCHAIN_SIGNATURE_LEN;\\n        address[] memory signers = new address[](sigCount);\\n        bytes32 r;\\n        bytes32 s;\\n        uint8 v;\\n        for(uint j = 0; j  < sigCount; j++){\\n            r = Utils.bytesToBytes32(Utils.slice(_sigList, j*POLYCHAIN_SIGNATURE_LEN, 32));\\n            s =  Utils.bytesToBytes32(Utils.slice(_sigList, j*POLYCHAIN_SIGNATURE_LEN + 32, 32));\\n            v =  uint8(_sigList[j*POLYCHAIN_SIGNATURE_LEN + 64]) + 27;\\n            signers[j] =  ecrecover(sha256(abi.encodePacked(hash)), v, r, s);\\n        }\\n        return Utils.containMAddresses(_keepers, signers, _m);\\n    }\", \"ECCUtils.merkleProve:function merkleProve(bytes memory _auditPath, bytes32 _root) internal pure returns (bytes memory) {\\n        uint256 off = 0;\\n        bytes memory value;\\n        (value, off)  = ZeroCopySource.NextVarBytes(_auditPath, off);\\n\\n        bytes32 hash = Utils.hashLeaf(value);\\n        uint size = (_auditPath.length - off) / 33;\\n        bytes32 nodeHash;\\n        byte pos;\\n        for (uint i = 0; i < size; i++) {\\n            (pos, off) = ZeroCopySource.NextByte(_auditPath, off);\\n            (nodeHash, off) = ZeroCopySource.NextHash(_auditPath, off);\\n            if (pos == 0x00) {\\n                hash = Utils.hashChildren(nodeHash, hash);\\n            } else if (pos == 0x01) {\\n                hash = Utils.hashChildren(hash, nodeHash);\\n            } else {\\n                revert(\\\"merkleProve, NextByte for position info failed\\\");\\n            }\\n        }\\n        require(hash == _root, \\\"merkleProve, expect root is not equal actual root\\\");\\n        return value;\\n    }\", \"EthCrossChainManager._executeCrossChainTx:function _executeCrossChainTx(address _toContract, bytes memory _method, bytes memory _args, bytes memory _fromContractAddr, uint64 _fromChainId) internal returns (bool){\\n        // Ensure the targeting contract gonna be invoked is indeed a contract rather than a normal account address\\n        require(Utils.isContract(_toContract), \\\"The passed in address is not a contract!\\\");\\n        bytes memory returnData;\\n        bool success;\\n        \\n        // The returnData will be bytes32, the last byte must be 01;\\n        (success, returnData) = _toContract.call(abi.encodePacked(bytes4(keccak256(abi.encodePacked(_method, \\\"(bytes,bytes,uint64)\\\"))), abi.encode(_args, _fromContractAddr, _fromChainId)));\\n        \\n        // Ensure the executation is successful\\n        require(success == true, \\\"EthCrossChain call business contract failed\\\");\\n        \\n        // Ensure the returned value is true\\n        require(returnData.length != 0, \\\"No return value from business contract!\\\");\\n        (bool res,) = ZeroCopySource.NextBool(returnData, 31);\\n        require(res == true, \\\"EthCrossChain call business contract return is not true\\\");\\n        \\n        return true;\\n    }\", \"ZeroCopySource.NextUint64:function NextUint64(bytes memory buff, uint256 offset) internal pure returns (uint64, uint256) {\\n        require(offset + 8 <= buff.length && offset < offset + 8, \\\"NextUint64, offset exceeds maximum\\\");\\n        uint64 v;\\n        assembly {\\n            let tmpbytes := mload(0x40)\\n            let byteLen := 0x08\\n            for {\\n                let tindex := 0x00\\n                let bindex := sub(byteLen, 0x01)\\n                let bvalue := mload(add(add(buff, 0x20), offset))\\n            } lt(tindex, byteLen) {\\n                tindex := add(tindex, 0x01)\\n                bindex := sub(bindex, 0x01)\\n            }{\\n                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))\\n            }\\n            mstore(0x40, add(tmpbytes, byteLen))\\n            v := mload(sub(tmpbytes, sub(0x20, byteLen)))\\n        }\\n        return (v, offset + 8);\\n    }\", \"ZeroCopySource.NextVarBytes:function NextVarBytes(bytes memory buff, uint256 offset) internal pure returns(bytes memory, uint256) {\\n        uint len;\\n        (len, offset) = NextVarUint(buff, offset);\\n        require(offset + len <= buff.length && offset < offset + len, \\\"NextVarBytes, offset exceeds maximum\\\");\\n        bytes memory tempBytes;\\n        assembly{\\n            switch iszero(len)\\n            case 0 {\\n                // Get a location of some free memory and store it in tempBytes as\\n                // Solidity does for memory variables.\\n                tempBytes := mload(0x40)\\n\\n                // The first word of the slice result is potentially a partial\\n                // word read from the original array. To read it, we calculate\\n                // the length of that partial word and start copying that many\\n                // bytes into the array. The first word we copy will start with\\n                // data we don't care about, but the last `lengthmod` bytes will\\n                // land at the beginning of the contents of the new array. When\\n                // we're done copying, we overwrite the full first word with\\n                // the actual length of the slice.\\n                let lengthmod := and(len, 31)\\n\\n                // The multiplication in the next line is necessary\\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\\n                // the following copy loop was copying the origin's length\\n                // and then ending prematurely not copying everything it should.\\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\\n                let end := add(mc, len)\\n\\n                for {\\n                    // The multiplication in the next line has the same exact purpose\\n                    // as the one above.\\n                    let cc := add(add(add(buff, lengthmod), mul(0x20, iszero(lengthmod))), offset)\\n                } lt(mc, end) {\\n                    mc := add(mc, 0x20)\\n                    cc := add(cc, 0x20)\\n                } {\\n                    mstore(mc, mload(cc))\\n                }\\n\\n                mstore(tempBytes, len)\\n\\n                //update free-memory pointer\\n                //allocating the array padded to 32 bytes like the compiler does now\\n                mstore(0x40, and(add(mc, 31), not(31)))\\n            }\\n            //if we want a zero-length slice let's just return a zero-length array\\n            default {\\n                tempBytes := mload(0x40)\\n\\n                mstore(0x40, add(tempBytes, 0x20))\\n            }\\n        }\\n\\n        return (tempBytes, offset + len);\\n    }\", \"ZeroCopySource.NextVarBytes:function NextVarBytes(bytes memory buff, uint256 offset) internal pure returns(bytes memory, uint256) {\\n        uint len;\\n        (len, offset) = NextVarUint(buff, offset);\\n        require(offset + len <= buff.length && offset < offset + len, \\\"NextVarBytes, offset exceeds maximum\\\");\\n        bytes memory tempBytes;\\n        assembly{\\n            switch iszero(len)\\n            case 0 {\\n                // Get a location of some free memory and store it in tempBytes as\\n                // Solidity does for memory variables.\\n                tempBytes := mload(0x40)\\n\\n                // The first word of the slice result is potentially a partial\\n                // word read from the original array. To read it, we calculate\\n                // the length of that partial word and start copying that many\\n                // bytes into the array. The first word we copy will start with\\n                // data we don't care about, but the last `lengthmod` bytes will\\n                // land at the beginning of the contents of the new array. When\\n                // we're done copying, we overwrite the full first word with\\n                // the actual length of the slice.\\n                let lengthmod := and(len, 31)\\n\\n                // The multiplication in the next line is necessary\\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\\n                // the following copy loop was copying the origin's length\\n                // and then ending prematurely not copying everything it should.\\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\\n                let end := add(mc, len)\\n\\n                for {\\n                    // The multiplication in the next line has the same exact purpose\\n                    // as the one above.\\n                    let cc := add(add(add(buff, lengthmod), mul(0x20, iszero(lengthmod))), offset)\\n                } lt(mc, end) {\\n                    mc := add(mc, 0x20)\\n                    cc := add(cc, 0x20)\\n                } {\\n                    mstore(mc, mload(cc))\\n                }\\n\\n                mstore(tempBytes, len)\\n\\n                //update free-memory pointer\\n                //allocating the array padded to 32 bytes like the compiler does now\\n                mstore(0x40, and(add(mc, 31), not(31)))\\n            }\\n            //if we want a zero-length slice let's just return a zero-length array\\n            default {\\n                tempBytes := mload(0x40)\\n\\n                mstore(0x40, add(tempBytes, 0x20))\\n            }\\n        }\\n\\n        return (tempBytes, offset + len);\\n    }\", \"ZeroCopySource.NextUint64:function NextUint64(bytes memory buff, uint256 offset) internal pure returns (uint64, uint256) {\\n        require(offset + 8 <= buff.length && offset < offset + 8, \\\"NextUint64, offset exceeds maximum\\\");\\n        uint64 v;\\n        assembly {\\n            let tmpbytes := mload(0x40)\\n            let byteLen := 0x08\\n            for {\\n                let tindex := 0x00\\n                let bindex := sub(byteLen, 0x01)\\n                let bvalue := mload(add(add(buff, 0x20), offset))\\n            } lt(tindex, byteLen) {\\n                tindex := add(tindex, 0x01)\\n                bindex := sub(bindex, 0x01)\\n            }{\\n                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))\\n            }\\n            mstore(0x40, add(tmpbytes, byteLen))\\n            v := mload(sub(tmpbytes, sub(0x20, byteLen)))\\n        }\\n        return (v, offset + 8);\\n    }\", \"ZeroCopySource.NextBytes20:function NextBytes20(bytes memory buff, uint256 offset) internal pure returns (bytes20 , uint256) {\\n        require(offset + 20 <= buff.length && offset < offset + 20, \\\"NextBytes20, offset exceeds maximum\\\");\\n        bytes20 v;\\n        assembly {\\n            v := mload(add(buff, add(offset, 0x20)))\\n        }\\n        return (v, offset + 20);\\n    }\", \"ZeroCopySource.NextHash:function NextHash(bytes memory buff, uint256 offset) internal pure returns (bytes32 , uint256) {\\n        require(offset + 32 <= buff.length && offset < offset + 32, \\\"NextHash, offset exceeds maximum\\\");\\n        bytes32 v;\\n        assembly {\\n            v := mload(add(buff, add(offset, 0x20)))\\n        }\\n        return (v, offset + 32);\\n    }\", \"ZeroCopySource.NextUint32:function NextUint32(bytes memory buff, uint256 offset) internal pure returns (uint32, uint256) {\\n        require(offset + 4 <= buff.length && offset < offset + 4, \\\"NextUint32, offset exceeds maximum\\\");\\n        uint32 v;\\n        assembly {\\n            let tmpbytes := mload(0x40)\\n            let byteLen := 0x04\\n            for {\\n                let tindex := 0x00\\n                let bindex := sub(byteLen, 0x01)\\n                let bvalue := mload(add(add(buff, 0x20), offset))\\n            } lt(tindex, byteLen) {\\n                tindex := add(tindex, 0x01)\\n                bindex := sub(bindex, 0x01)\\n            }{\\n                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))\\n            }\\n            mstore(0x40, add(tmpbytes, byteLen))\\n            v := mload(sub(tmpbytes, sub(0x20, byteLen)))\\n        }\\n        return (v, offset + 4);\\n    }\", \"ZeroCopySource.NextVarBytes:function NextVarBytes(bytes memory buff, uint256 offset) internal pure returns(bytes memory, uint256) {\\n        uint len;\\n        (len, offset) = NextVarUint(buff, offset);\\n        require(offset + len <= buff.length && offset < offset + len, \\\"NextVarBytes, offset exceeds maximum\\\");\\n        bytes memory tempBytes;\\n        assembly{\\n            switch iszero(len)\\n            case 0 {\\n                // Get a location of some free memory and store it in tempBytes as\\n                // Solidity does for memory variables.\\n                tempBytes := mload(0x40)\\n\\n                // The first word of the slice result is potentially a partial\\n                // word read from the original array. To read it, we calculate\\n                // the length of that partial word and start copying that many\\n                // bytes into the array. The first word we copy will start with\\n                // data we don't care about, but the last `lengthmod` bytes will\\n                // land at the beginning of the contents of the new array. When\\n                // we're done copying, we overwrite the full first word with\\n                // the actual length of the slice.\\n                let lengthmod := and(len, 31)\\n\\n                // The multiplication in the next line is necessary\\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\\n                // the following copy loop was copying the origin's length\\n                // and then ending prematurely not copying everything it should.\\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\\n                let end := add(mc, len)\\n\\n                for {\\n                    // The multiplication in the next line has the same exact purpose\\n                    // as the one above.\\n                    let cc := add(add(add(buff, lengthmod), mul(0x20, iszero(lengthmod))), offset)\\n                } lt(mc, end) {\\n                    mc := add(mc, 0x20)\\n                    cc := add(cc, 0x20)\\n                } {\\n                    mstore(mc, mload(cc))\\n                }\\n\\n                mstore(tempBytes, len)\\n\\n                //update free-memory pointer\\n                //allocating the array padded to 32 bytes like the compiler does now\\n                mstore(0x40, and(add(mc, 31), not(31)))\\n            }\\n            //if we want a zero-length slice let's just return a zero-length array\\n            default {\\n                tempBytes := mload(0x40)\\n\\n                mstore(0x40, add(tempBytes, 0x20))\\n            }\\n        }\\n\\n        return (tempBytes, offset + len);\\n    }\", \"ZeroCopySource.NextUint64:function NextUint64(bytes memory buff, uint256 offset) internal pure returns (uint64, uint256) {\\n        require(offset + 8 <= buff.length && offset < offset + 8, \\\"NextUint64, offset exceeds maximum\\\");\\n        uint64 v;\\n        assembly {\\n            let tmpbytes := mload(0x40)\\n            let byteLen := 0x08\\n            for {\\n                let tindex := 0x00\\n                let bindex := sub(byteLen, 0x01)\\n                let bvalue := mload(add(add(buff, 0x20), offset))\\n            } lt(tindex, byteLen) {\\n                tindex := add(tindex, 0x01)\\n                bindex := sub(bindex, 0x01)\\n            }{\\n                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))\\n            }\\n            mstore(0x40, add(tmpbytes, byteLen))\\n            v := mload(sub(tmpbytes, sub(0x20, byteLen)))\\n        }\\n        return (v, offset + 8);\\n    }\", \"Utils.containMAddresses:function containMAddresses(address[] memory _keepers, address[] memory _signers, uint _m) internal pure returns (bool){\\n        uint m = 0;\\n        for(uint i = 0; i < _signers.length; i++){\\n            for (uint j = 0; j < _keepers.length; j++) {\\n                if (_signers[i] == _keepers[j]) {\\n                    m++;\\n                    delete _keepers[j];\\n                }\\n            }\\n        }\\n        return m >= _m;\\n    }\", \"Utils.slice:function slice(\\n        bytes memory _bytes,\\n        uint _start,\\n        uint _length\\n    )\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        require(_bytes.length >= (_start + _length));\\n\\n        bytes memory tempBytes;\\n\\n        assembly {\\n            switch iszero(_length)\\n            case 0 {\\n                // Get a location of some free memory and store it in tempBytes as\\n                // Solidity does for memory variables.\\n                tempBytes := mload(0x40)\\n\\n                // The first word of the slice result is potentially a partial\\n                // word read from the original array. To read it, we calculate\\n                // the length of that partial word and start copying that many\\n                // bytes into the array. The first word we copy will start with\\n                // data we don't care about, but the last `lengthmod` bytes will\\n                // land at the beginning of the contents of the new array. When\\n                // we're done copying, we overwrite the full first word with\\n                // the actual length of the slice.\\n                // lengthmod <= _length % 32\\n                let lengthmod := and(_length, 31)\\n\\n                // The multiplication in the next line is necessary\\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\\n                // the following copy loop was copying the origin's length\\n                // and then ending prematurely not copying everything it should.\\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\\n                let end := add(mc, _length)\\n\\n                for {\\n                    // The multiplication in the next line has the same exact purpose\\n                    // as the one above.\\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\\n                } lt(mc, end) {\\n                    mc := add(mc, 0x20)\\n                    cc := add(cc, 0x20)\\n                } {\\n                    mstore(mc, mload(cc))\\n                }\\n\\n                mstore(tempBytes, _length)\\n\\n                //update free-memory pointer\\n                //allocating the array padded to 32 bytes like the compiler does now\\n                mstore(0x40, and(add(mc, 31), not(31)))\\n            }\\n            //if we want a zero-length slice let's just return a zero-length array\\n            default {\\n                tempBytes := mload(0x40)\\n\\n                mstore(0x40, add(tempBytes, 0x20))\\n            }\\n        }\\n\\n        return tempBytes;\\n    }\", \"ZeroCopySource.NextVarBytes:function NextVarBytes(bytes memory buff, uint256 offset) internal pure returns(bytes memory, uint256) {\\n        uint len;\\n        (len, offset) = NextVarUint(buff, offset);\\n        require(offset + len <= buff.length && offset < offset + len, \\\"NextVarBytes, offset exceeds maximum\\\");\\n        bytes memory tempBytes;\\n        assembly{\\n            switch iszero(len)\\n            case 0 {\\n                // Get a location of some free memory and store it in tempBytes as\\n                // Solidity does for memory variables.\\n                tempBytes := mload(0x40)\\n\\n                // The first word of the slice result is potentially a partial\\n                // word read from the original array. To read it, we calculate\\n                // the length of that partial word and start copying that many\\n                // bytes into the array. The first word we copy will start with\\n                // data we don't care about, but the last `lengthmod` bytes will\\n                // land at the beginning of the contents of the new array. When\\n                // we're done copying, we overwrite the full first word with\\n                // the actual length of the slice.\\n                let lengthmod := and(len, 31)\\n\\n                // The multiplication in the next line is necessary\\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\\n                // the following copy loop was copying the origin's length\\n                // and then ending prematurely not copying everything it should.\\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\\n                let end := add(mc, len)\\n\\n                for {\\n                    // The multiplication in the next line has the same exact purpose\\n                    // as the one above.\\n                    let cc := add(add(add(buff, lengthmod), mul(0x20, iszero(lengthmod))), offset)\\n                } lt(mc, end) {\\n                    mc := add(mc, 0x20)\\n                    cc := add(cc, 0x20)\\n                } {\\n                    mstore(mc, mload(cc))\\n                }\\n\\n                mstore(tempBytes, len)\\n\\n                //update free-memory pointer\\n                //allocating the array padded to 32 bytes like the compiler does now\\n                mstore(0x40, and(add(mc, 31), not(31)))\\n            }\\n            //if we want a zero-length slice let's just return a zero-length array\\n            default {\\n                tempBytes := mload(0x40)\\n\\n                mstore(0x40, add(tempBytes, 0x20))\\n            }\\n        }\\n\\n        return (tempBytes, offset + len);\\n    }\", \"ZeroCopySource.NextHash:function NextHash(bytes memory buff, uint256 offset) internal pure returns (bytes32 , uint256) {\\n        require(offset + 32 <= buff.length && offset < offset + 32, \\\"NextHash, offset exceeds maximum\\\");\\n        bytes32 v;\\n        assembly {\\n            v := mload(add(buff, add(offset, 0x20)))\\n        }\\n        return (v, offset + 32);\\n    }\", \"Utils.hashChildren:function hashChildren(bytes32 _l, bytes32  _r) internal pure returns (bytes32 result)  {\\n        result = sha256(abi.encodePacked(bytes1(0x01), _l, _r));\\n    }\", \"Utils.hashLeaf:function hashLeaf(bytes memory _data) internal pure returns (bytes32 result)  {\\n        result = sha256(abi.encodePacked(byte(0x0), _data));\\n    }\", \"ZeroCopySource.NextByte:function NextByte(bytes memory buff, uint256 offset) internal pure returns (byte, uint256) {\\n        require(offset + 1 <= buff.length && offset < offset + 1, \\\"NextByte, Offset exceeds maximum\\\");\\n        byte v;\\n        assembly{\\n            v := mload(add(add(buff, 0x20), offset))\\n        }\\n        return (v, offset + 1);\\n    }\", \"ZeroCopySource.NextBool:function NextBool(bytes memory buff, uint256 offset) internal pure returns(bool, uint256) {\\n        require(offset + 1 <= buff.length && offset < offset + 1, \\\"Offset exceeds limit\\\");\\n        // byte === bytes1\\n        byte v;\\n        assembly{\\n            v := mload(add(add(buff, 0x20), offset))\\n        }\\n        bool value;\\n        if (v == 0x01) {\\n\\t\\t    value = true;\\n    \\t} else if (v == 0x00) {\\n            value = false;\\n        } else {\\n            revert(\\\"NextBool value error\\\");\\n        }\\n        return (value, offset + 1);\\n    }\", \"Utils.isContract:function isContract(address account) internal view returns (bool) {\\n        // This method relies in extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\n        // for accounts without code, i.e. `keccak256('')`\\n        bytes32 codehash;\\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { codehash := extcodehash(account) }\\n        return (codehash != 0x0 && codehash != accountHash);\\n    }\", \"ZeroCopySource.NextVarUint:function NextVarUint(bytes memory buff, uint256 offset) internal pure returns(uint, uint256) {\\n        byte v;\\n        (v, offset) = NextByte(buff, offset);\\n\\n        uint value;\\n        if (v == 0xFD) {\\n            // return NextUint16(buff, offset);\\n            (value, offset) = NextUint16(buff, offset);\\n            require(value >= 0xFD && value <= 0xFFFF, \\\"NextUint16, value outside range\\\");\\n            return (value, offset);\\n        } else if (v == 0xFE) {\\n            // return NextUint32(buff, offset);\\n            (value, offset) = NextUint32(buff, offset);\\n            require(value > 0xFFFF && value <= 0xFFFFFFFF, \\\"NextVarUint, value outside range\\\");\\n            return (value, offset);\\n        } else if (v == 0xFF) {\\n            // return NextUint64(buff, offset);\\n            (value, offset) = NextUint64(buff, offset);\\n            require(value > 0xFFFFFFFF, \\\"NextVarUint, value outside range\\\");\\n            return (value, offset);\\n        } else{\\n            // return (uint8(v), offset);\\n            value = uint8(v);\\n            require(value < 0xFD, \\\"NextVarUint, value outside range\\\");\\n            return (value, offset);\\n        }\\n    }\", \"ZeroCopySource.NextByte:function NextByte(bytes memory buff, uint256 offset) internal pure returns (byte, uint256) {\\n        require(offset + 1 <= buff.length && offset < offset + 1, \\\"NextByte, Offset exceeds maximum\\\");\\n        byte v;\\n        assembly{\\n            v := mload(add(add(buff, 0x20), offset))\\n        }\\n        return (v, offset + 1);\\n    }\", \"ZeroCopySource.NextUint64:function NextUint64(bytes memory buff, uint256 offset) internal pure returns (uint64, uint256) {\\n        require(offset + 8 <= buff.length && offset < offset + 8, \\\"NextUint64, offset exceeds maximum\\\");\\n        uint64 v;\\n        assembly {\\n            let tmpbytes := mload(0x40)\\n            let byteLen := 0x08\\n            for {\\n                let tindex := 0x00\\n                let bindex := sub(byteLen, 0x01)\\n                let bvalue := mload(add(add(buff, 0x20), offset))\\n            } lt(tindex, byteLen) {\\n                tindex := add(tindex, 0x01)\\n                bindex := sub(bindex, 0x01)\\n            }{\\n                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))\\n            }\\n            mstore(0x40, add(tmpbytes, byteLen))\\n            v := mload(sub(tmpbytes, sub(0x20, byteLen)))\\n        }\\n        return (v, offset + 8);\\n    }\", \"ZeroCopySource.NextUint16:function NextUint16(bytes memory buff, uint256 offset) internal pure returns (uint16, uint256) {\\n        require(offset + 2 <= buff.length && offset < offset + 2, \\\"NextUint16, offset exceeds maximum\\\");\\n        \\n        uint16 v;\\n        assembly {\\n            let tmpbytes := mload(0x40)\\n            let bvalue := mload(add(add(buff, 0x20), offset))\\n            mstore8(tmpbytes, byte(0x01, bvalue))\\n            mstore8(add(tmpbytes, 0x01), byte(0, bvalue))\\n            mstore(0x40, add(tmpbytes, 0x02))\\n            v := mload(sub(tmpbytes, 0x1e))\\n        }\\n        return (v, offset + 2);\\n    }\", \"ZeroCopySource.NextUint32:function NextUint32(bytes memory buff, uint256 offset) internal pure returns (uint32, uint256) {\\n        require(offset + 4 <= buff.length && offset < offset + 4, \\\"NextUint32, offset exceeds maximum\\\");\\n        uint32 v;\\n        assembly {\\n            let tmpbytes := mload(0x40)\\n            let byteLen := 0x04\\n            for {\\n                let tindex := 0x00\\n                let bindex := sub(byteLen, 0x01)\\n                let bvalue := mload(add(add(buff, 0x20), offset))\\n            } lt(tindex, byteLen) {\\n                tindex := add(tindex, 0x01)\\n                bindex := sub(bindex, 0x01)\\n            }{\\n                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))\\n            }\\n            mstore(0x40, add(tmpbytes, byteLen))\\n            v := mload(sub(tmpbytes, sub(0x20, byteLen)))\\n        }\\n        return (v, offset + 4);\\n    }\"]\n}\n",
            "outputs1": [
                [
                    {
                        "parameter": "toMerkleValue.fromChainID",
                        "attribute": "sourceChainID",
                        "reason": "The parameter represents the originating chain ID in the cross-chain transaction, matching the attribute description. The naming convention ('fromChainID') aligns with the attribute's purpose."
                    },
                    {
                        "parameter": "toMerkleValue.makeTxParam.toChainId",
                        "attribute": "toChainID",
                        "reason": "This parameter specifies the target chain ID for the cross-chain transaction, directly corresponding to the attribute. The 'toChainId' name clearly indicates its purpose."
                    },
                    {
                        "parameter": "proof",
                        "attribute": "proof",
                        "reason": "The parameter is used as cryptographic proof to verify transaction authenticity from the source chain, exactly matching the attribute's definition. The naming is identical and unambiguous."
                    },
                    {
                        "parameter": "_method",
                        "attribute": "externalCallFunction",
                        "reason": "_method in _executeCrossChainTx represents the function to be called on the target contract, aligning with 'externalCallFunction'. However, it's passed as bytes rather than a clear function signature, creating minor ambiguity."
                    },
                    {
                        "parameter": "_toContract",
                        "attribute": "externalCallAddress",
                        "reason": "_toContract specifies the target contract address for post-transfer execution, matching 'externalCallAddress'. The context confirms this is where external logic will be invoked."
                    }
                ]
            ],
            "v_prompt1": "\nYou are a rigorous cross-chain protocol auditor and data consistency verifier. Carefully review whether the meaning of each cross-chain attribute and parameter in the code is consistent, assign a confidence score (0-100%), and state the reason for the given confidence score.\n\nInput format: You will receive a JSON object as input, structured as follows:\n{\n\"correspondence\":    // Array of attribute-parameter correspondences in the code\n[\n{\n\"attribute\": \"...\", // Input cross-chain attribute\n\"parameter\": \"...\", // Corresponding parameter\n\"reason\": \"...\" // Brief explanation: why this parameter was chosen, and possible ambiguities\n}\n...\n],\n\"code\":\"...\" // Cross-chain contract code\n}\n\nOutput format: Return a JSON array, each item structured as follows:\n[ \n{\n\"parameter\": \"...\", // The parameter name in the code most likely corresponding to the attribute\n\"attribute\": \"...\", // Input cross-chain attribute\n\"score\":\"...\", // Assigned confidence score\n\"reason\": \"...\" // Brief explanation for the given confidence score\n}, ... \n]\nInput:\n{\n\"correspondence\": [{\"parameter\": \"toMerkleValue.fromChainID\", \"attribute\": \"sourceChainID\", \"reason\": \"The parameter represents the originating chain ID in the cross-chain transaction, matching the attribute description. The naming convention ('fromChainID') aligns with the attribute's purpose.\"}, {\"parameter\": \"toMerkleValue.makeTxParam.toChainId\", \"attribute\": \"toChainID\", \"reason\": \"This parameter specifies the target chain ID for the cross-chain transaction, directly corresponding to the attribute. The 'toChainId' name clearly indicates its purpose.\"}, {\"parameter\": \"proof\", \"attribute\": \"proof\", \"reason\": \"The parameter is used as cryptographic proof to verify transaction authenticity from the source chain, exactly matching the attribute's definition. The naming is identical and unambiguous.\"}, {\"parameter\": \"_method\", \"attribute\": \"externalCallFunction\", \"reason\": \"_method in _executeCrossChainTx represents the function to be called on the target contract, aligning with 'externalCallFunction'. However, it's passed as bytes rather than a clear function signature, creating minor ambiguity.\"}, {\"parameter\": \"_toContract\", \"attribute\": \"externalCallAddress\", \"reason\": \"_toContract specifies the target contract address for post-transfer execution, matching 'externalCallAddress'. The context confirms this is where external logic will be invoked.\"}],\n\"code\": [\"EthCrossChainManager.verifyHeaderAndExecuteTx:function verifyHeaderAndExecuteTx(bytes memory proof, bytes memory rawHeader, bytes memory headerProof, bytes memory curRawHeader,bytes memory headerSig) whenNotPaused public returns (bool){\\n        ECCUtils.Header memory header = ECCUtils.deserializeHeader(rawHeader);\\n        // Load ehereum cross chain data contract\\n        IEthCrossChainData eccd = IEthCrossChainData(EthCrossChainDataAddress);\\n        \\n        // Get stored consensus public key bytes of current poly chain epoch and deserialize Poly chain consensus public key bytes to address[]\\n        address[] memory polyChainBKs = ECCUtils.deserializeKeepers(eccd.getCurEpochConPubKeyBytes());\\n\\n        uint256 curEpochStartHeight = eccd.getCurEpochStartHeight();\\n\\n        uint n = polyChainBKs.length;\\n        if (header.height >= curEpochStartHeight) {\\n            // It's enough to verify rawHeader signature\\n            require(ECCUtils.verifySig(rawHeader, headerSig, polyChainBKs, n - ( n - 1) / 3), \\\"Verify poly chain header signature failed!\\\");\\n        } else {\\n            // We need to verify the signature of curHeader \\n            require(ECCUtils.verifySig(curRawHeader, headerSig, polyChainBKs, n - ( n - 1) / 3), \\\"Verify poly chain current epoch header signature failed!\\\");\\n\\n            // Then use curHeader.StateRoot and headerProof to verify rawHeader.CrossStateRoot\\n            ECCUtils.Header memory curHeader = ECCUtils.deserializeHeader(curRawHeader);\\n            bytes memory proveValue = ECCUtils.merkleProve(headerProof, curHeader.blockRoot);\\n            require(ECCUtils.getHeaderHash(rawHeader) == Utils.bytesToBytes32(proveValue), \\\"verify header proof failed!\\\");\\n        }\\n        \\n        // Through rawHeader.CrossStatesRoot, the toMerkleValue or cross chain msg can be verified and parsed from proof\\n        bytes memory toMerkleValueBs = ECCUtils.merkleProve(proof, header.crossStatesRoot);\\n        \\n        // Parse the toMerkleValue struct and make sure the tx has not been processed, then mark this tx as processed\\n        ECCUtils.ToMerkleValue memory toMerkleValue = ECCUtils.deserializeMerkleValue(toMerkleValueBs);\\n        require(!eccd.checkIfFromChainTxExist(toMerkleValue.fromChainID, Utils.bytesToBytes32(toMerkleValue.txHash)), \\\"the transaction has been executed!\\\");\\n        require(eccd.markFromChainTxExist(toMerkleValue.fromChainID, Utils.bytesToBytes32(toMerkleValue.txHash)), \\\"Save crosschain tx exist failed!\\\");\\n        \\n        // Ethereum ChainId is 2, we need to check the transaction is for Ethereum network\\n        require(toMerkleValue.makeTxParam.toChainId == uint64(2), \\\"This Tx is not aiming at Ethereum network!\\\");\\n        \\n        // Obtain the targeting contract, so that Ethereum cross chain manager contract can trigger the executation of cross chain tx on Ethereum side\\n        address toContract = Utils.bytesToAddress(toMerkleValue.makeTxParam.toContract);\\n        \\n        //TODO: check this part to make sure we commit the next line when doing local net UT test\\n        require(_executeCrossChainTx(toContract, toMerkleValue.makeTxParam.method, toMerkleValue.makeTxParam.args, toMerkleValue.makeTxParam.fromContract, toMerkleValue.fromChainID), \\\"Execute CrossChain Tx failed!\\\");\\n\\n        // Fire the cross chain event denoting the executation of cross chain tx is successful,\\n        // and this tx is coming from other public chains to current Ethereum network\\n        emit VerifyHeaderAndExecuteTxEvent(toMerkleValue.fromChainID, toMerkleValue.makeTxParam.toContract, toMerkleValue.txHash, toMerkleValue.makeTxParam.txHash);\\n\\n        return true;\\n    }\", \"ECCUtils.deserializeMerkleValue:function deserializeMerkleValue(bytes memory _valueBs) internal pure returns (ToMerkleValue memory) {\\n        ToMerkleValue memory toMerkleValue;\\n        uint256 off = 0;\\n\\n        (toMerkleValue.txHash, off) = ZeroCopySource.NextVarBytes(_valueBs, off);\\n\\n        (toMerkleValue.fromChainID, off) = ZeroCopySource.NextUint64(_valueBs, off);\\n\\n        TxParam memory txParam;\\n\\n        (txParam.txHash, off) = ZeroCopySource.NextVarBytes(_valueBs, off);\\n        \\n        (txParam.crossChainId, off) = ZeroCopySource.NextVarBytes(_valueBs, off);\\n\\n        (txParam.fromContract, off) = ZeroCopySource.NextVarBytes(_valueBs, off);\\n\\n        (txParam.toChainId, off) = ZeroCopySource.NextUint64(_valueBs, off);\\n\\n        (txParam.toContract, off) = ZeroCopySource.NextVarBytes(_valueBs, off);\\n\\n        (txParam.method, off) = ZeroCopySource.NextVarBytes(_valueBs, off);\\n\\n        (txParam.args, off) = ZeroCopySource.NextVarBytes(_valueBs, off);\\n        toMerkleValue.makeTxParam = txParam;\\n\\n        return toMerkleValue;\\n    }\", \"ECCUtils.deserializeKeepers:function deserializeKeepers(bytes memory keepersBytes) internal pure returns (address[] memory) {\\n        uint256 off = 0;\\n        uint64 keeperLen;\\n        (keeperLen, off) = ZeroCopySource.NextUint64(keepersBytes, off);\\n        address[] memory keepers = new address[](keeperLen);\\n        bytes memory keeperBytes;\\n        for(uint i = 0; i < keeperLen; i++) {\\n            (keeperBytes, off) = ZeroCopySource.NextVarBytes(keepersBytes, off);\\n            keepers[i] = Utils.bytesToAddress(keeperBytes);\\n        }\\n        return keepers;\\n    }\", \"Utils.bytesToBytes32:function bytesToBytes32(bytes memory _bs) internal pure returns (bytes32 value) {\\n        require(_bs.length == 32, \\\"bytes length is not 32.\\\");\\n        assembly {\\n            // load 32 bytes from memory starting from position _bs + 0x20 since the first 0x20 bytes stores _bs length\\n            value := mload(add(_bs, 0x20))\\n        }\\n    }\", \"Utils.bytesToAddress:function bytesToAddress(bytes memory _bs) internal pure returns (address addr)\\n    {\\n        require(_bs.length == 20, \\\"bytes length does not match address\\\");\\n        assembly {\\n            // for _bs, first word store _bs.length, second word store _bs.value\\n            // load 32 bytes from mem[_bs+20], convert it into Uint160, meaning we take last 20 bytes as addr (address).\\n            addr := mload(add(_bs, 0x14))\\n        }\\n\\n    }\", \"ECCUtils.deserializeHeader:function deserializeHeader(bytes memory _headerBs) internal pure returns (Header memory) {\\n        Header memory header;\\n        uint256 off = 0;\\n        (header.version, off)  = ZeroCopySource.NextUint32(_headerBs, off);\\n\\n        (header.chainId, off) = ZeroCopySource.NextUint64(_headerBs, off);\\n\\n        (header.prevBlockHash, off) = ZeroCopySource.NextHash(_headerBs, off);\\n\\n        (header.transactionsRoot, off) = ZeroCopySource.NextHash(_headerBs, off);\\n\\n        (header.crossStatesRoot, off) = ZeroCopySource.NextHash(_headerBs, off);\\n\\n        (header.blockRoot, off) = ZeroCopySource.NextHash(_headerBs, off);\\n\\n        (header.timestamp, off) = ZeroCopySource.NextUint32(_headerBs, off);\\n\\n        (header.height, off) = ZeroCopySource.NextUint32(_headerBs, off);\\n\\n        (header.consensusData, off) = ZeroCopySource.NextUint64(_headerBs, off);\\n\\n        (header.consensusPayload, off) = ZeroCopySource.NextVarBytes(_headerBs, off);\\n\\n        (header.nextBookkeeper, off) = ZeroCopySource.NextBytes20(_headerBs, off);\\n\\n        return header;\\n    }\", \"ECCUtils.getHeaderHash:function getHeaderHash(bytes memory rawHeader) internal pure returns (bytes32) {\\n        return sha256(abi.encodePacked(sha256(rawHeader)));\\n    }\", \"ECCUtils.verifySig:function verifySig(bytes memory _rawHeader, bytes memory _sigList, address[] memory _keepers, uint _m) internal pure returns (bool){\\n        bytes32 hash = getHeaderHash(_rawHeader);\\n\\n        uint signed = 0;\\n        uint sigCount = _sigList.length / POLYCHAIN_SIGNATURE_LEN;\\n        address[] memory signers = new address[](sigCount);\\n        bytes32 r;\\n        bytes32 s;\\n        uint8 v;\\n        for(uint j = 0; j  < sigCount; j++){\\n            r = Utils.bytesToBytes32(Utils.slice(_sigList, j*POLYCHAIN_SIGNATURE_LEN, 32));\\n            s =  Utils.bytesToBytes32(Utils.slice(_sigList, j*POLYCHAIN_SIGNATURE_LEN + 32, 32));\\n            v =  uint8(_sigList[j*POLYCHAIN_SIGNATURE_LEN + 64]) + 27;\\n            signers[j] =  ecrecover(sha256(abi.encodePacked(hash)), v, r, s);\\n        }\\n        return Utils.containMAddresses(_keepers, signers, _m);\\n    }\", \"ECCUtils.merkleProve:function merkleProve(bytes memory _auditPath, bytes32 _root) internal pure returns (bytes memory) {\\n        uint256 off = 0;\\n        bytes memory value;\\n        (value, off)  = ZeroCopySource.NextVarBytes(_auditPath, off);\\n\\n        bytes32 hash = Utils.hashLeaf(value);\\n        uint size = (_auditPath.length - off) / 33;\\n        bytes32 nodeHash;\\n        byte pos;\\n        for (uint i = 0; i < size; i++) {\\n            (pos, off) = ZeroCopySource.NextByte(_auditPath, off);\\n            (nodeHash, off) = ZeroCopySource.NextHash(_auditPath, off);\\n            if (pos == 0x00) {\\n                hash = Utils.hashChildren(nodeHash, hash);\\n            } else if (pos == 0x01) {\\n                hash = Utils.hashChildren(hash, nodeHash);\\n            } else {\\n                revert(\\\"merkleProve, NextByte for position info failed\\\");\\n            }\\n        }\\n        require(hash == _root, \\\"merkleProve, expect root is not equal actual root\\\");\\n        return value;\\n    }\", \"EthCrossChainManager._executeCrossChainTx:function _executeCrossChainTx(address _toContract, bytes memory _method, bytes memory _args, bytes memory _fromContractAddr, uint64 _fromChainId) internal returns (bool){\\n        // Ensure the targeting contract gonna be invoked is indeed a contract rather than a normal account address\\n        require(Utils.isContract(_toContract), \\\"The passed in address is not a contract!\\\");\\n        bytes memory returnData;\\n        bool success;\\n        \\n        // The returnData will be bytes32, the last byte must be 01;\\n        (success, returnData) = _toContract.call(abi.encodePacked(bytes4(keccak256(abi.encodePacked(_method, \\\"(bytes,bytes,uint64)\\\"))), abi.encode(_args, _fromContractAddr, _fromChainId)));\\n        \\n        // Ensure the executation is successful\\n        require(success == true, \\\"EthCrossChain call business contract failed\\\");\\n        \\n        // Ensure the returned value is true\\n        require(returnData.length != 0, \\\"No return value from business contract!\\\");\\n        (bool res,) = ZeroCopySource.NextBool(returnData, 31);\\n        require(res == true, \\\"EthCrossChain call business contract return is not true\\\");\\n        \\n        return true;\\n    }\", \"ZeroCopySource.NextUint64:function NextUint64(bytes memory buff, uint256 offset) internal pure returns (uint64, uint256) {\\n        require(offset + 8 <= buff.length && offset < offset + 8, \\\"NextUint64, offset exceeds maximum\\\");\\n        uint64 v;\\n        assembly {\\n            let tmpbytes := mload(0x40)\\n            let byteLen := 0x08\\n            for {\\n                let tindex := 0x00\\n                let bindex := sub(byteLen, 0x01)\\n                let bvalue := mload(add(add(buff, 0x20), offset))\\n            } lt(tindex, byteLen) {\\n                tindex := add(tindex, 0x01)\\n                bindex := sub(bindex, 0x01)\\n            }{\\n                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))\\n            }\\n            mstore(0x40, add(tmpbytes, byteLen))\\n            v := mload(sub(tmpbytes, sub(0x20, byteLen)))\\n        }\\n        return (v, offset + 8);\\n    }\", \"ZeroCopySource.NextVarBytes:function NextVarBytes(bytes memory buff, uint256 offset) internal pure returns(bytes memory, uint256) {\\n        uint len;\\n        (len, offset) = NextVarUint(buff, offset);\\n        require(offset + len <= buff.length && offset < offset + len, \\\"NextVarBytes, offset exceeds maximum\\\");\\n        bytes memory tempBytes;\\n        assembly{\\n            switch iszero(len)\\n            case 0 {\\n                // Get a location of some free memory and store it in tempBytes as\\n                // Solidity does for memory variables.\\n                tempBytes := mload(0x40)\\n\\n                // The first word of the slice result is potentially a partial\\n                // word read from the original array. To read it, we calculate\\n                // the length of that partial word and start copying that many\\n                // bytes into the array. The first word we copy will start with\\n                // data we don't care about, but the last `lengthmod` bytes will\\n                // land at the beginning of the contents of the new array. When\\n                // we're done copying, we overwrite the full first word with\\n                // the actual length of the slice.\\n                let lengthmod := and(len, 31)\\n\\n                // The multiplication in the next line is necessary\\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\\n                // the following copy loop was copying the origin's length\\n                // and then ending prematurely not copying everything it should.\\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\\n                let end := add(mc, len)\\n\\n                for {\\n                    // The multiplication in the next line has the same exact purpose\\n                    // as the one above.\\n                    let cc := add(add(add(buff, lengthmod), mul(0x20, iszero(lengthmod))), offset)\\n                } lt(mc, end) {\\n                    mc := add(mc, 0x20)\\n                    cc := add(cc, 0x20)\\n                } {\\n                    mstore(mc, mload(cc))\\n                }\\n\\n                mstore(tempBytes, len)\\n\\n                //update free-memory pointer\\n                //allocating the array padded to 32 bytes like the compiler does now\\n                mstore(0x40, and(add(mc, 31), not(31)))\\n            }\\n            //if we want a zero-length slice let's just return a zero-length array\\n            default {\\n                tempBytes := mload(0x40)\\n\\n                mstore(0x40, add(tempBytes, 0x20))\\n            }\\n        }\\n\\n        return (tempBytes, offset + len);\\n    }\", \"ZeroCopySource.NextVarBytes:function NextVarBytes(bytes memory buff, uint256 offset) internal pure returns(bytes memory, uint256) {\\n        uint len;\\n        (len, offset) = NextVarUint(buff, offset);\\n        require(offset + len <= buff.length && offset < offset + len, \\\"NextVarBytes, offset exceeds maximum\\\");\\n        bytes memory tempBytes;\\n        assembly{\\n            switch iszero(len)\\n            case 0 {\\n                // Get a location of some free memory and store it in tempBytes as\\n                // Solidity does for memory variables.\\n                tempBytes := mload(0x40)\\n\\n                // The first word of the slice result is potentially a partial\\n                // word read from the original array. To read it, we calculate\\n                // the length of that partial word and start copying that many\\n                // bytes into the array. The first word we copy will start with\\n                // data we don't care about, but the last `lengthmod` bytes will\\n                // land at the beginning of the contents of the new array. When\\n                // we're done copying, we overwrite the full first word with\\n                // the actual length of the slice.\\n                let lengthmod := and(len, 31)\\n\\n                // The multiplication in the next line is necessary\\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\\n                // the following copy loop was copying the origin's length\\n                // and then ending prematurely not copying everything it should.\\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\\n                let end := add(mc, len)\\n\\n                for {\\n                    // The multiplication in the next line has the same exact purpose\\n                    // as the one above.\\n                    let cc := add(add(add(buff, lengthmod), mul(0x20, iszero(lengthmod))), offset)\\n                } lt(mc, end) {\\n                    mc := add(mc, 0x20)\\n                    cc := add(cc, 0x20)\\n                } {\\n                    mstore(mc, mload(cc))\\n                }\\n\\n                mstore(tempBytes, len)\\n\\n                //update free-memory pointer\\n                //allocating the array padded to 32 bytes like the compiler does now\\n                mstore(0x40, and(add(mc, 31), not(31)))\\n            }\\n            //if we want a zero-length slice let's just return a zero-length array\\n            default {\\n                tempBytes := mload(0x40)\\n\\n                mstore(0x40, add(tempBytes, 0x20))\\n            }\\n        }\\n\\n        return (tempBytes, offset + len);\\n    }\", \"ZeroCopySource.NextUint64:function NextUint64(bytes memory buff, uint256 offset) internal pure returns (uint64, uint256) {\\n        require(offset + 8 <= buff.length && offset < offset + 8, \\\"NextUint64, offset exceeds maximum\\\");\\n        uint64 v;\\n        assembly {\\n            let tmpbytes := mload(0x40)\\n            let byteLen := 0x08\\n            for {\\n                let tindex := 0x00\\n                let bindex := sub(byteLen, 0x01)\\n                let bvalue := mload(add(add(buff, 0x20), offset))\\n            } lt(tindex, byteLen) {\\n                tindex := add(tindex, 0x01)\\n                bindex := sub(bindex, 0x01)\\n            }{\\n                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))\\n            }\\n            mstore(0x40, add(tmpbytes, byteLen))\\n            v := mload(sub(tmpbytes, sub(0x20, byteLen)))\\n        }\\n        return (v, offset + 8);\\n    }\", \"ZeroCopySource.NextBytes20:function NextBytes20(bytes memory buff, uint256 offset) internal pure returns (bytes20 , uint256) {\\n        require(offset + 20 <= buff.length && offset < offset + 20, \\\"NextBytes20, offset exceeds maximum\\\");\\n        bytes20 v;\\n        assembly {\\n            v := mload(add(buff, add(offset, 0x20)))\\n        }\\n        return (v, offset + 20);\\n    }\", \"ZeroCopySource.NextHash:function NextHash(bytes memory buff, uint256 offset) internal pure returns (bytes32 , uint256) {\\n        require(offset + 32 <= buff.length && offset < offset + 32, \\\"NextHash, offset exceeds maximum\\\");\\n        bytes32 v;\\n        assembly {\\n            v := mload(add(buff, add(offset, 0x20)))\\n        }\\n        return (v, offset + 32);\\n    }\", \"ZeroCopySource.NextUint32:function NextUint32(bytes memory buff, uint256 offset) internal pure returns (uint32, uint256) {\\n        require(offset + 4 <= buff.length && offset < offset + 4, \\\"NextUint32, offset exceeds maximum\\\");\\n        uint32 v;\\n        assembly {\\n            let tmpbytes := mload(0x40)\\n            let byteLen := 0x04\\n            for {\\n                let tindex := 0x00\\n                let bindex := sub(byteLen, 0x01)\\n                let bvalue := mload(add(add(buff, 0x20), offset))\\n            } lt(tindex, byteLen) {\\n                tindex := add(tindex, 0x01)\\n                bindex := sub(bindex, 0x01)\\n            }{\\n                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))\\n            }\\n            mstore(0x40, add(tmpbytes, byteLen))\\n            v := mload(sub(tmpbytes, sub(0x20, byteLen)))\\n        }\\n        return (v, offset + 4);\\n    }\", \"ZeroCopySource.NextVarBytes:function NextVarBytes(bytes memory buff, uint256 offset) internal pure returns(bytes memory, uint256) {\\n        uint len;\\n        (len, offset) = NextVarUint(buff, offset);\\n        require(offset + len <= buff.length && offset < offset + len, \\\"NextVarBytes, offset exceeds maximum\\\");\\n        bytes memory tempBytes;\\n        assembly{\\n            switch iszero(len)\\n            case 0 {\\n                // Get a location of some free memory and store it in tempBytes as\\n                // Solidity does for memory variables.\\n                tempBytes := mload(0x40)\\n\\n                // The first word of the slice result is potentially a partial\\n                // word read from the original array. To read it, we calculate\\n                // the length of that partial word and start copying that many\\n                // bytes into the array. The first word we copy will start with\\n                // data we don't care about, but the last `lengthmod` bytes will\\n                // land at the beginning of the contents of the new array. When\\n                // we're done copying, we overwrite the full first word with\\n                // the actual length of the slice.\\n                let lengthmod := and(len, 31)\\n\\n                // The multiplication in the next line is necessary\\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\\n                // the following copy loop was copying the origin's length\\n                // and then ending prematurely not copying everything it should.\\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\\n                let end := add(mc, len)\\n\\n                for {\\n                    // The multiplication in the next line has the same exact purpose\\n                    // as the one above.\\n                    let cc := add(add(add(buff, lengthmod), mul(0x20, iszero(lengthmod))), offset)\\n                } lt(mc, end) {\\n                    mc := add(mc, 0x20)\\n                    cc := add(cc, 0x20)\\n                } {\\n                    mstore(mc, mload(cc))\\n                }\\n\\n                mstore(tempBytes, len)\\n\\n                //update free-memory pointer\\n                //allocating the array padded to 32 bytes like the compiler does now\\n                mstore(0x40, and(add(mc, 31), not(31)))\\n            }\\n            //if we want a zero-length slice let's just return a zero-length array\\n            default {\\n                tempBytes := mload(0x40)\\n\\n                mstore(0x40, add(tempBytes, 0x20))\\n            }\\n        }\\n\\n        return (tempBytes, offset + len);\\n    }\", \"ZeroCopySource.NextUint64:function NextUint64(bytes memory buff, uint256 offset) internal pure returns (uint64, uint256) {\\n        require(offset + 8 <= buff.length && offset < offset + 8, \\\"NextUint64, offset exceeds maximum\\\");\\n        uint64 v;\\n        assembly {\\n            let tmpbytes := mload(0x40)\\n            let byteLen := 0x08\\n            for {\\n                let tindex := 0x00\\n                let bindex := sub(byteLen, 0x01)\\n                let bvalue := mload(add(add(buff, 0x20), offset))\\n            } lt(tindex, byteLen) {\\n                tindex := add(tindex, 0x01)\\n                bindex := sub(bindex, 0x01)\\n            }{\\n                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))\\n            }\\n            mstore(0x40, add(tmpbytes, byteLen))\\n            v := mload(sub(tmpbytes, sub(0x20, byteLen)))\\n        }\\n        return (v, offset + 8);\\n    }\", \"Utils.containMAddresses:function containMAddresses(address[] memory _keepers, address[] memory _signers, uint _m) internal pure returns (bool){\\n        uint m = 0;\\n        for(uint i = 0; i < _signers.length; i++){\\n            for (uint j = 0; j < _keepers.length; j++) {\\n                if (_signers[i] == _keepers[j]) {\\n                    m++;\\n                    delete _keepers[j];\\n                }\\n            }\\n        }\\n        return m >= _m;\\n    }\", \"Utils.slice:function slice(\\n        bytes memory _bytes,\\n        uint _start,\\n        uint _length\\n    )\\n        internal\\n        pure\\n        returns (bytes memory)\\n    {\\n        require(_bytes.length >= (_start + _length));\\n\\n        bytes memory tempBytes;\\n\\n        assembly {\\n            switch iszero(_length)\\n            case 0 {\\n                // Get a location of some free memory and store it in tempBytes as\\n                // Solidity does for memory variables.\\n                tempBytes := mload(0x40)\\n\\n                // The first word of the slice result is potentially a partial\\n                // word read from the original array. To read it, we calculate\\n                // the length of that partial word and start copying that many\\n                // bytes into the array. The first word we copy will start with\\n                // data we don't care about, but the last `lengthmod` bytes will\\n                // land at the beginning of the contents of the new array. When\\n                // we're done copying, we overwrite the full first word with\\n                // the actual length of the slice.\\n                // lengthmod <= _length % 32\\n                let lengthmod := and(_length, 31)\\n\\n                // The multiplication in the next line is necessary\\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\\n                // the following copy loop was copying the origin's length\\n                // and then ending prematurely not copying everything it should.\\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\\n                let end := add(mc, _length)\\n\\n                for {\\n                    // The multiplication in the next line has the same exact purpose\\n                    // as the one above.\\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\\n                } lt(mc, end) {\\n                    mc := add(mc, 0x20)\\n                    cc := add(cc, 0x20)\\n                } {\\n                    mstore(mc, mload(cc))\\n                }\\n\\n                mstore(tempBytes, _length)\\n\\n                //update free-memory pointer\\n                //allocating the array padded to 32 bytes like the compiler does now\\n                mstore(0x40, and(add(mc, 31), not(31)))\\n            }\\n            //if we want a zero-length slice let's just return a zero-length array\\n            default {\\n                tempBytes := mload(0x40)\\n\\n                mstore(0x40, add(tempBytes, 0x20))\\n            }\\n        }\\n\\n        return tempBytes;\\n    }\", \"ZeroCopySource.NextVarBytes:function NextVarBytes(bytes memory buff, uint256 offset) internal pure returns(bytes memory, uint256) {\\n        uint len;\\n        (len, offset) = NextVarUint(buff, offset);\\n        require(offset + len <= buff.length && offset < offset + len, \\\"NextVarBytes, offset exceeds maximum\\\");\\n        bytes memory tempBytes;\\n        assembly{\\n            switch iszero(len)\\n            case 0 {\\n                // Get a location of some free memory and store it in tempBytes as\\n                // Solidity does for memory variables.\\n                tempBytes := mload(0x40)\\n\\n                // The first word of the slice result is potentially a partial\\n                // word read from the original array. To read it, we calculate\\n                // the length of that partial word and start copying that many\\n                // bytes into the array. The first word we copy will start with\\n                // data we don't care about, but the last `lengthmod` bytes will\\n                // land at the beginning of the contents of the new array. When\\n                // we're done copying, we overwrite the full first word with\\n                // the actual length of the slice.\\n                let lengthmod := and(len, 31)\\n\\n                // The multiplication in the next line is necessary\\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\\n                // the following copy loop was copying the origin's length\\n                // and then ending prematurely not copying everything it should.\\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\\n                let end := add(mc, len)\\n\\n                for {\\n                    // The multiplication in the next line has the same exact purpose\\n                    // as the one above.\\n                    let cc := add(add(add(buff, lengthmod), mul(0x20, iszero(lengthmod))), offset)\\n                } lt(mc, end) {\\n                    mc := add(mc, 0x20)\\n                    cc := add(cc, 0x20)\\n                } {\\n                    mstore(mc, mload(cc))\\n                }\\n\\n                mstore(tempBytes, len)\\n\\n                //update free-memory pointer\\n                //allocating the array padded to 32 bytes like the compiler does now\\n                mstore(0x40, and(add(mc, 31), not(31)))\\n            }\\n            //if we want a zero-length slice let's just return a zero-length array\\n            default {\\n                tempBytes := mload(0x40)\\n\\n                mstore(0x40, add(tempBytes, 0x20))\\n            }\\n        }\\n\\n        return (tempBytes, offset + len);\\n    }\", \"ZeroCopySource.NextHash:function NextHash(bytes memory buff, uint256 offset) internal pure returns (bytes32 , uint256) {\\n        require(offset + 32 <= buff.length && offset < offset + 32, \\\"NextHash, offset exceeds maximum\\\");\\n        bytes32 v;\\n        assembly {\\n            v := mload(add(buff, add(offset, 0x20)))\\n        }\\n        return (v, offset + 32);\\n    }\", \"Utils.hashChildren:function hashChildren(bytes32 _l, bytes32  _r) internal pure returns (bytes32 result)  {\\n        result = sha256(abi.encodePacked(bytes1(0x01), _l, _r));\\n    }\", \"Utils.hashLeaf:function hashLeaf(bytes memory _data) internal pure returns (bytes32 result)  {\\n        result = sha256(abi.encodePacked(byte(0x0), _data));\\n    }\", \"ZeroCopySource.NextByte:function NextByte(bytes memory buff, uint256 offset) internal pure returns (byte, uint256) {\\n        require(offset + 1 <= buff.length && offset < offset + 1, \\\"NextByte, Offset exceeds maximum\\\");\\n        byte v;\\n        assembly{\\n            v := mload(add(add(buff, 0x20), offset))\\n        }\\n        return (v, offset + 1);\\n    }\", \"ZeroCopySource.NextBool:function NextBool(bytes memory buff, uint256 offset) internal pure returns(bool, uint256) {\\n        require(offset + 1 <= buff.length && offset < offset + 1, \\\"Offset exceeds limit\\\");\\n        // byte === bytes1\\n        byte v;\\n        assembly{\\n            v := mload(add(add(buff, 0x20), offset))\\n        }\\n        bool value;\\n        if (v == 0x01) {\\n\\t\\t    value = true;\\n    \\t} else if (v == 0x00) {\\n            value = false;\\n        } else {\\n            revert(\\\"NextBool value error\\\");\\n        }\\n        return (value, offset + 1);\\n    }\", \"Utils.isContract:function isContract(address account) internal view returns (bool) {\\n        // This method relies in extcodesize, which returns 0 for contracts in\\n        // construction, since the code is only stored at the end of the\\n        // constructor execution.\\n\\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\\n        // for accounts without code, i.e. `keccak256('')`\\n        bytes32 codehash;\\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\\n        // solhint-disable-next-line no-inline-assembly\\n        assembly { codehash := extcodehash(account) }\\n        return (codehash != 0x0 && codehash != accountHash);\\n    }\", \"ZeroCopySource.NextVarUint:function NextVarUint(bytes memory buff, uint256 offset) internal pure returns(uint, uint256) {\\n        byte v;\\n        (v, offset) = NextByte(buff, offset);\\n\\n        uint value;\\n        if (v == 0xFD) {\\n            // return NextUint16(buff, offset);\\n            (value, offset) = NextUint16(buff, offset);\\n            require(value >= 0xFD && value <= 0xFFFF, \\\"NextUint16, value outside range\\\");\\n            return (value, offset);\\n        } else if (v == 0xFE) {\\n            // return NextUint32(buff, offset);\\n            (value, offset) = NextUint32(buff, offset);\\n            require(value > 0xFFFF && value <= 0xFFFFFFFF, \\\"NextVarUint, value outside range\\\");\\n            return (value, offset);\\n        } else if (v == 0xFF) {\\n            // return NextUint64(buff, offset);\\n            (value, offset) = NextUint64(buff, offset);\\n            require(value > 0xFFFFFFFF, \\\"NextVarUint, value outside range\\\");\\n            return (value, offset);\\n        } else{\\n            // return (uint8(v), offset);\\n            value = uint8(v);\\n            require(value < 0xFD, \\\"NextVarUint, value outside range\\\");\\n            return (value, offset);\\n        }\\n    }\", \"ZeroCopySource.NextByte:function NextByte(bytes memory buff, uint256 offset) internal pure returns (byte, uint256) {\\n        require(offset + 1 <= buff.length && offset < offset + 1, \\\"NextByte, Offset exceeds maximum\\\");\\n        byte v;\\n        assembly{\\n            v := mload(add(add(buff, 0x20), offset))\\n        }\\n        return (v, offset + 1);\\n    }\", \"ZeroCopySource.NextUint64:function NextUint64(bytes memory buff, uint256 offset) internal pure returns (uint64, uint256) {\\n        require(offset + 8 <= buff.length && offset < offset + 8, \\\"NextUint64, offset exceeds maximum\\\");\\n        uint64 v;\\n        assembly {\\n            let tmpbytes := mload(0x40)\\n            let byteLen := 0x08\\n            for {\\n                let tindex := 0x00\\n                let bindex := sub(byteLen, 0x01)\\n                let bvalue := mload(add(add(buff, 0x20), offset))\\n            } lt(tindex, byteLen) {\\n                tindex := add(tindex, 0x01)\\n                bindex := sub(bindex, 0x01)\\n            }{\\n                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))\\n            }\\n            mstore(0x40, add(tmpbytes, byteLen))\\n            v := mload(sub(tmpbytes, sub(0x20, byteLen)))\\n        }\\n        return (v, offset + 8);\\n    }\", \"ZeroCopySource.NextUint16:function NextUint16(bytes memory buff, uint256 offset) internal pure returns (uint16, uint256) {\\n        require(offset + 2 <= buff.length && offset < offset + 2, \\\"NextUint16, offset exceeds maximum\\\");\\n        \\n        uint16 v;\\n        assembly {\\n            let tmpbytes := mload(0x40)\\n            let bvalue := mload(add(add(buff, 0x20), offset))\\n            mstore8(tmpbytes, byte(0x01, bvalue))\\n            mstore8(add(tmpbytes, 0x01), byte(0, bvalue))\\n            mstore(0x40, add(tmpbytes, 0x02))\\n            v := mload(sub(tmpbytes, 0x1e))\\n        }\\n        return (v, offset + 2);\\n    }\", \"ZeroCopySource.NextUint32:function NextUint32(bytes memory buff, uint256 offset) internal pure returns (uint32, uint256) {\\n        require(offset + 4 <= buff.length && offset < offset + 4, \\\"NextUint32, offset exceeds maximum\\\");\\n        uint32 v;\\n        assembly {\\n            let tmpbytes := mload(0x40)\\n            let byteLen := 0x04\\n            for {\\n                let tindex := 0x00\\n                let bindex := sub(byteLen, 0x01)\\n                let bvalue := mload(add(add(buff, 0x20), offset))\\n            } lt(tindex, byteLen) {\\n                tindex := add(tindex, 0x01)\\n                bindex := sub(bindex, 0x01)\\n            }{\\n                mstore8(add(tmpbytes, tindex), byte(bindex, bvalue))\\n            }\\n            mstore(0x40, add(tmpbytes, byteLen))\\n            v := mload(sub(tmpbytes, sub(0x20, byteLen)))\\n        }\\n        return (v, offset + 4);\\n    }\"]:\n}\n\n",
            "v_outputs1": [
                [
                    {
                        "parameter": "toMerkleValue.fromChainID",
                        "attribute": "sourceChainID",
                        "score": "100%",
                        "reason": "The parameter 'fromChainID' in 'toMerkleValue' directly corresponds to the attribute 'sourceChainID' as it represents the originating chain ID in the cross-chain transaction. The naming and usage context are perfectly aligned."
                    },
                    {
                        "parameter": "toMerkleValue.makeTxParam.toChainId",
                        "attribute": "toChainID",
                        "score": "100%",
                        "reason": "The parameter 'toChainId' within 'makeTxParam' clearly specifies the target chain ID for the cross-chain transaction, matching the attribute 'toChainID' exactly in both purpose and naming."
                    },
                    {
                        "parameter": "proof",
                        "attribute": "proof",
                        "score": "100%",
                        "reason": "The parameter 'proof' is used as cryptographic proof to verify transaction authenticity from the source chain, which is identical to the attribute's definition. The naming and usage are unambiguous."
                    },
                    {
                        "parameter": "_method",
                        "attribute": "externalCallFunction",
                        "score": "90%",
                        "reason": "_method in _executeCrossChainTx represents the function to be called on the target contract, aligning with 'externalCallFunction'. However, it's passed as bytes rather than a clear function signature, creating minor ambiguity."
                    },
                    {
                        "parameter": "_toContract",
                        "attribute": "externalCallAddress",
                        "score": "100%",
                        "reason": "_toContract specifies the target contract address for post-transfer execution, matching 'externalCallAddress'. The context confirms this is where external logic will be invoked."
                    }
                ]
            ],
            "formatted_outputs1": {
                "toMerkleValue.fromChainID": {
                    "sourceChainID": {
                        "reason": "The parameter represents the originating chain ID in the cross-chain transaction, matching the attribute description. The naming convention ('fromChainID') aligns with the attribute's purpose.",
                        "score": "100%",
                        "s_reason": "The parameter 'fromChainID' in 'toMerkleValue' directly corresponds to the attribute 'sourceChainID' as it represents the originating chain ID in the cross-chain transaction. The naming and usage context are perfectly aligned."
                    }
                },
                "toMerkleValue.makeTxParam.toChainId": {
                    "toChainID": {
                        "reason": "This parameter specifies the target chain ID for the cross-chain transaction, directly corresponding to the attribute. The 'toChainId' name clearly indicates its purpose.",
                        "score": "100%",
                        "s_reason": "The parameter 'toChainId' within 'makeTxParam' clearly specifies the target chain ID for the cross-chain transaction, matching the attribute 'toChainID' exactly in both purpose and naming."
                    }
                },
                "proof": {
                    "proof": {
                        "reason": "The parameter is used as cryptographic proof to verify transaction authenticity from the source chain, exactly matching the attribute's definition. The naming is identical and unambiguous.",
                        "score": "100%",
                        "s_reason": "The parameter 'proof' is used as cryptographic proof to verify transaction authenticity from the source chain, which is identical to the attribute's definition. The naming and usage are unambiguous."
                    }
                },
                "_method": {
                    "externalCallFunction": {
                        "reason": "_method in _executeCrossChainTx represents the function to be called on the target contract, aligning with 'externalCallFunction'. However, it's passed as bytes rather than a clear function signature, creating minor ambiguity.",
                        "score": "90%",
                        "s_reason": "_method in _executeCrossChainTx represents the function to be called on the target contract, aligning with 'externalCallFunction'. However, it's passed as bytes rather than a clear function signature, creating minor ambiguity."
                    }
                },
                "_toContract": {
                    "externalCallAddress": {
                        "reason": "_toContract specifies the target contract address for post-transfer execution, matching 'externalCallAddress'. The context confirms this is where external logic will be invoked.",
                        "score": "100%",
                        "s_reason": "_toContract specifies the target contract address for post-transfer execution, matching 'externalCallAddress'. The context confirms this is where external logic will be invoked."
                    }
                }
            }
        },
        "step2": {},
        "step3": {},
        "step4": {},
        "final_result": {},
        "context": {
            "event": "VerifyHeaderAndExecuteTxEvent",
            "call_graph": "verifyHeaderAndExecuteTx",
            "state_variables": {
                "EthCrossChainDataAddress": "address public EthCrossChainDataAddress;",
                "ConKeepersPkBytes": "bytes public ConKeepersPkBytes;",
                "FromChainTxExist": "mapping(uint64 => mapping(bytes32 => bool)) FromChainTxExist;",
                "POLYCHAIN_SIGNATURE_LEN": "uint constant POLYCHAIN_SIGNATURE_LEN = 65;",
                "CurEpochStartHeight": "uint32 public CurEpochStartHeight;"
            },
            "external_functions": [
                "function getCurEpochConPubKeyBytes() public view returns (bytes memory){ return ConKeepersPkBytes;}",
                "function checkIfFromChainTxExist(uint64 fromChainId, bytes32 fromChainTx) public view returns (bool){ return FromChainTxExist[fromChainId][fromChainTx];}",
                "function markFromChainTxExist(uint64 fromChainId, bytes32 fromChainTx) public whenNotPaused onlyOwner returns (bool){ FromChainTxExist[fromChainId][fromChainTx] = true; return true;}",
                "function getCurEpochStartHeight() public view returns (uint32){ return CurEpochStartHeight;}"
            ]
        },
        "step1-time": 43.4355583190918
    }
}