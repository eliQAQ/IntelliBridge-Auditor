{"Function call relationship": "MappingBase.receive->MappingBase._decreaseAuthQuota", "code": ["MappingBase.receive:function receive(uint256 fromChainId, address to, uint256 nonce, uint256 volume, Signature[] memory signatures) virtual external payable {\n        _chargeFee();\n        require(received[fromChainId][to][nonce] == 0, 'withdrawn already');\n        uint N = signatures.length;\n        require(N >= Factory(factory).getConfig(_minSignatures_), 'too few signatures');\n        for(uint i=0; i<N; i++) {\n            for(uint j=0; j<i; j++)\n                require(signatures[i].signatory != signatures[j].signatory, 'repetitive signatory');\n            bytes32 structHash = keccak256(abi.encode(RECEIVE_TYPEHASH, fromChainId, to, nonce, volume, signatures[i].signatory));\n            bytes32 digest = keccak256(abi.encodePacked(\"\\x19\\x01\", _DOMAIN_SEPARATOR, structHash));\n            address signatory = ecrecover(digest, signatures[i].v, signatures[i].r, signatures[i].s);\n            require(signatory != address(0), \"invalid signature\");\n            require(signatory == signatures[i].signatory, \"unauthorized\");\n            _decreaseAuthQuota(signatures[i].signatory, volume);\n            emit Authorize(fromChainId, to, nonce, volume, signatory);\n        }\n        received[fromChainId][to][nonce] = volume;\n        _receive(to, volume);\n        emit Receive(fromChainId, to, nonce, volume);\n    }", "MappingBase._decreaseAuthQuota:function _decreaseAuthQuota(address signatory, uint decrement) virtual internal updateAutoQuota(signatory) returns (uint quota) {\n        quota = _authQuotas[signatory].sub(decrement);\n        _authQuotas[signatory] = quota;\n        emit DecreaseAuthQuota(signatory, decrement, quota);\n    }", "MappingBase._chargeFee:function _chargeFee() virtual internal {\n        require(msg.value >= Math.min(Factory(factory).getConfig(_fee_), 0.1 ether), 'fee is too low');\n        address payable feeTo = address(Factory(factory).getConfig(_feeTo_));\n        if(feeTo == address(0))\n            feeTo = address(uint160(factory));\n        feeTo.transfer(msg.value);\n        emit ChargeFee(_msgSender(), feeTo, msg.value);\n    }", "MappingBase._receive:function _receive(address to, uint256 volume) virtual internal;\n    \n    function _chargeFee() virtual internal {\n        require(msg.value >= Math.min(Factory(factory).getConfig(_fee_), 0.1 ether), 'fee is too low');\n        address payable feeTo = address(Factory(factory).getConfig(_feeTo_));\n        if(feeTo == address(0))\n            feeTo = address(uint160(factory));\n        feeTo.transfer(msg.value);\n        emit ChargeFee(_msgSender(), feeTo, msg.value);\n    }", "Math.min:function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }", "ERC20UpgradeSafe._transfer:function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }", "ERC20UpgradeSafe._mint:function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }", "ERC20UpgradeSafe._beforeTokenTransfer:function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }", "ERC20UpgradeSafe._beforeTokenTransfer:function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }"]}