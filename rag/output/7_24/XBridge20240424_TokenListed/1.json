{"Function call relationship": "XBridge.listToken", "code": ["XBridge.listToken:function listToken(tokenInfo memory baseToken, tokenInfo memory correspondingToken, bool _isMintable) external payable {\n        address _baseToken = baseToken.token;\n        address _correspondingToken = correspondingToken.token;\n        require(_baseToken != address(0), \"INVALID_ADDR\");\n        require(_correspondingToken != address(0), \"INVALID_ADDR\");\n        require(tokenToTokenWithChainId[baseToken.chain][correspondingToken.chain][_baseToken] == address(0) && tokenToTokenWithChainId[baseToken.chain][correspondingToken.chain][_correspondingToken] == address(0), \"THIS_PAIR_ALREADY_LISTED\");\n\n        isMintableWithChainId[baseToken.chain][correspondingToken.chain][_baseToken][_correspondingToken] = _isMintable;\n        isMintableWithChainId[baseToken.chain][correspondingToken.chain][_correspondingToken][_baseToken] = _isMintable;\n        isMintableWithChainId[correspondingToken.chain][baseToken.chain][_baseToken][_correspondingToken] = _isMintable;\n        isMintableWithChainId[correspondingToken.chain][baseToken.chain][_correspondingToken][_baseToken] = _isMintable;\n\n        tokenToTokenWithChainId[baseToken.chain][correspondingToken.chain][_baseToken] = _correspondingToken;\n        tokenToTokenWithChainId[baseToken.chain][correspondingToken.chain][_correspondingToken] = _baseToken;\n        tokenToTokenWithChainId[correspondingToken.chain][baseToken.chain][_baseToken] = _correspondingToken;\n        tokenToTokenWithChainId[correspondingToken.chain][baseToken.chain][_correspondingToken] = _baseToken;\n\n\n        if(_isMintable) {\n            isWrappedWithChainId[baseToken.chain][correspondingToken.chain][_correspondingToken] = true;\n            isWrappedWithChainId[correspondingToken.chain][baseToken.chain][_correspondingToken] = true;\n            isWrapped[_correspondingToken] = true;\n\n        }\n\n        tokenOwnerWithChainId[baseToken.chain][correspondingToken.chain][_baseToken][_correspondingToken] = msg.sender;\n        tokenOwnerWithChainId[baseToken.chain][correspondingToken.chain][_correspondingToken][_baseToken] = msg.sender;\n        tokenOwnerWithChainId[correspondingToken.chain][baseToken.chain][_baseToken][_correspondingToken] = msg.sender;\n        tokenOwnerWithChainId[correspondingToken.chain][baseToken.chain][_correspondingToken][_baseToken] = msg.sender;\n\n        if(_baseToken == _correspondingToken) _tokenOwner[_baseToken] = msg.sender;\n        else {\n            if(_baseToken.code.length > 0) _tokenOwner[_baseToken] = msg.sender;\n            else _tokenOwner[_correspondingToken] = msg.sender;\n        }\n\n        if(!excludeFeeFromListing[msg.sender]) transferListingFee(listingFeeCollector, msg.sender, msg.value);\n\n        emit TokenListed(_baseToken, baseToken.chain, _correspondingToken, correspondingToken.chain, _isMintable, msg.sender);\n\n    }", "XBridge.transferListingFee:function transferListingFee(address to, address _user,  uint256 _value) private nonReentrant {\n        require(to != address(0), \"CANT_SEND_TO_NULL_ADDRESS\");\n        require(_value >= listingFee, \"INCREASE_LISTING_FEE\");\n        (bool success, ) = payable(to).call{value:listingFee}(\"\");\n        require(success, \"LISTING_FEE_TRANSFER_FAILED\");\n        uint256 remainingEth = _value - listingFee;\n        if (remainingEth > 0) {\n            (success,) = payable(_user).call{value: remainingEth}(\"\");\n            require(success, \"REFUND_REMAINING_ETHER_SENT_FAILED\");\n        }\n    }"]}