{"Function call relationship": "CBridgeFacet.swapAndStartBridgeTokensViaCBridge->LibSwap.swap", "code": ["CBridgeFacet.swapAndStartBridgeTokensViaCBridge:function swapAndStartBridgeTokensViaCBridge(\n        LiFiData memory _lifiData,\n        LibSwap.SwapData[] calldata _swapData,\n        CBridgeData memory _cBridgeData\n    ) public payable {\n        if (_cBridgeData.token != address(0)) {\n            uint256 _fromTokenBalance = LibAsset.getOwnBalance(_cBridgeData.token);\n\n            // Swap\n            for (uint8 i; i < _swapData.length; i++) {\n                LibSwap.swap(_lifiData.transactionId, _swapData[i]);\n            }\n\n            uint256 _postSwapBalance = LibAsset.getOwnBalance(_cBridgeData.token) - _fromTokenBalance;\n\n            require(_postSwapBalance > 0, \"ERR_INVALID_AMOUNT\");\n\n            _cBridgeData.amount = _postSwapBalance;\n        } else {\n            uint256 _fromBalance = address(this).balance;\n\n            // Swap\n            for (uint8 i; i < _swapData.length; i++) {\n                LibSwap.swap(_lifiData.transactionId, _swapData[i]);\n            }\n\n            uint256 _postSwapBalance = address(this).balance - _fromBalance;\n\n            require(_postSwapBalance > 0, \"ERR_INVALID_AMOUNT\");\n\n            _cBridgeData.amount = _postSwapBalance;\n        }\n\n        _startBridge(_cBridgeData);\n\n        emit LiFiTransferStarted(\n            _lifiData.transactionId,\n            _lifiData.integrator,\n            _lifiData.referrer,\n            _lifiData.sendingAssetId,\n            _lifiData.receivingAssetId,\n            _lifiData.receiver,\n            _lifiData.amount,\n            _lifiData.destinationChainId,\n            block.timestamp\n        );\n    }", "LibSwap.swap:function swap(bytes32 transactionId, SwapData calldata _swapData) internal {\n        uint256 fromAmount = _swapData.fromAmount;\n        uint256 toAmount = LibAsset.getOwnBalance(_swapData.receivingAssetId);\n        address fromAssetId = _swapData.sendingAssetId;\n        if (!LibAsset.isNativeAsset(fromAssetId) && LibAsset.getOwnBalance(fromAssetId) < fromAmount) {\n            LibAsset.transferFromERC20(_swapData.sendingAssetId, msg.sender, address(this), fromAmount);\n        }\n\n        if (!LibAsset.isNativeAsset(fromAssetId)) {\n            LibAsset.approveERC20(IERC20(fromAssetId), _swapData.approveTo, fromAmount);\n        }\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory res) = _swapData.callTo.call{ value: msg.value }(_swapData.callData);\n        if (!success) {\n            string memory reason = LibUtil.getRevertMsg(res);\n            revert(reason);\n        }\n\n        toAmount = LibAsset.getOwnBalance(_swapData.receivingAssetId) - toAmount;\n        emit AssetSwapped(\n            transactionId,\n            _swapData.callTo,\n            _swapData.sendingAssetId,\n            _swapData.receivingAssetId,\n            fromAmount,\n            toAmount,\n            block.timestamp\n        );\n    }", "LibAsset.getOwnBalance:function getOwnBalance(address assetId) internal view returns (uint256) {\n        return isNativeAsset(assetId) ? address(this).balance : IERC20(assetId).balanceOf(address(this));\n    }", "LibAsset.isNativeAsset:function isNativeAsset(address assetId) internal pure returns (bool) {\n        return assetId == NATIVE_ASSETID;\n    }", "LibAsset.transferFromERC20:function transferFromERC20(\n        address assetId,\n        address from,\n        address to,\n        uint256 amount\n    ) internal {\n        SafeERC20.safeTransferFrom(IERC20(assetId), from, to, amount);\n    }", "LibAsset.approveERC20:function approveERC20(\n        IERC20 assetId,\n        address spender,\n        uint256 amount\n    ) internal {\n        if (isNativeAsset(address(assetId))) return;\n        uint256 allowance = assetId.allowance(address(this), spender);\n        if (allowance < amount) {\n            if (allowance > 0) SafeERC20.safeApprove(IERC20(assetId), spender, 0);\n            SafeERC20.safeApprove(IERC20(assetId), spender, MAX_INT);\n        }\n    }", "LibUtil.getRevertMsg:function getRevertMsg(bytes memory _res) internal pure returns (string memory) {\n        // If the _res length is less than 68, then the transaction failed silently (without a revert message)\n        if (_res.length < 68) return \"Transaction reverted silently\";\n        bytes memory revertData = _res.slice(4, _res.length - 4); // Remove the selector which is the first 4 bytes\n        return abi.decode(revertData, (string)); // All that remains is the revert string\n    }", "LibAsset.getOwnBalance:function getOwnBalance(address assetId) internal view returns (uint256) {\n        return isNativeAsset(assetId) ? address(this).balance : IERC20(assetId).balanceOf(address(this));\n    }", "CBridgeFacet._startBridge:function _startBridge(CBridgeData memory _cBridgeData) internal {\n        Storage storage s = getStorage();\n        address bridge = _bridge();\n\n        // Do CBridge stuff\n        require(s.cBridgeChainId != _cBridgeData.dstChainId, \"Cannot bridge to the same network.\");\n\n        if (LibAsset.isNativeAsset(_cBridgeData.token)) {\n            ICBridge(bridge).sendNative(\n                _cBridgeData.receiver,\n                _cBridgeData.amount,\n                _cBridgeData.dstChainId,\n                _cBridgeData.nonce,\n                _cBridgeData.maxSlippage\n            );\n        } else {\n            // Give CBridge approval to bridge tokens\n            LibAsset.approveERC20(IERC20(_cBridgeData.token), bridge, _cBridgeData.amount);\n            // solhint-disable check-send-result\n            ICBridge(bridge).send(\n                _cBridgeData.receiver,\n                _cBridgeData.token,\n                _cBridgeData.amount,\n                _cBridgeData.dstChainId,\n                _cBridgeData.nonce,\n                _cBridgeData.maxSlippage\n            );\n        }\n    }", "CBridgeFacet.getStorage:function getStorage() internal pure returns (Storage storage s) {\n        bytes32 namespace = NAMESPACE;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            s.slot := namespace\n        }\n    }", "CBridgeFacet._bridge:function _bridge() internal view returns (address) {\n        Storage storage s = getStorage();\n        return s.cBridge;\n    }", "SafeERC20.safeTransferFrom:function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }", "SafeERC20.safeApprove:function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }", "LibBytes.slice:function slice(\n        bytes memory _bytes,\n        uint256 _start,\n        uint256 _length\n    ) internal pure returns (bytes memory) {\n        require(_length + 31 >= _length, \"slice_overflow\");\n        require(_bytes.length >= _start + _length, \"slice_outOfBounds\");\n\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n            case 0 {\n                // Get a location of some free memory and store it in tempBytes as\n                // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n                // The first word of the slice result is potentially a partial\n                // word read from the original array. To read it, we calculate\n                // the length of that partial word and start copying that many\n                // bytes into the array. The first word we copy will start with\n                // data we don't care about, but the last `lengthmod` bytes will\n                // land at the beginning of the contents of the new array. When\n                // we're done copying, we overwrite the full first word with\n                // the actual length of the slice.\n                let lengthmod := and(_length, 31)\n\n                // The multiplication in the next line is necessary\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n                // the following copy loop was copying the origin's length\n                // and then ending prematurely not copying everything it should.\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, _length)\n\n                for {\n                    // The multiplication in the next line has the same exact purpose\n                    // as the one above.\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    mstore(mc, mload(cc))\n                }\n\n                mstore(tempBytes, _length)\n\n                //update free-memory pointer\n                //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let's just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n                //zero out the 32 bytes slice we are about to return\n                //we need to do it because Solidity does not garbage collect\n                mstore(tempBytes, 0)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }", "SafeERC20._callOptionalReturn:function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }", "SafeERC20._callOptionalReturn:function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }", "Address.functionCall:function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }", "Address.functionCallWithValue:function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }", "Address.verifyCallResult:function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }", "Address.isContract:function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }"]}