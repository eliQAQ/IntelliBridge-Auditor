{"Function call relationship": "Replica.process", "code": ["Replica.process:function process(bytes memory _message) public returns (bool _success) {\n        // ensure message was meant for this domain\n        bytes29 _m = _message.ref(0);\n        require(_m.destination() == localDomain, \"!destination\");\n        // ensure message has been proven\n        bytes32 _messageHash = _m.keccak();\n        require(acceptableRoot(messages[_messageHash]), \"!proven\");\n        // check re-entrancy guard\n        require(entered == 1, \"!reentrant\");\n        entered = 0;\n        // update message status as processed\n        messages[_messageHash] = LEGACY_STATUS_PROCESSED;\n        // call handle function\n        IMessageRecipient(_m.recipientAddress()).handle(\n            _m.origin(),\n            _m.nonce(),\n            _m.sender(),\n            _m.body().clone()\n        );\n        // emit process results\n        emit Process(_messageHash, true, \"\");\n        // reset re-entrancy guard\n        entered = 1;\n        // return true\n        return true;\n    }", "Replica.acceptableRoot:function acceptableRoot(bytes32 _root) public view returns (bool) {\n        // this is backwards-compatibility for messages proven/processed\n        // under previous versions\n        if (_root == LEGACY_STATUS_PROVEN) return true;\n        if (_root == LEGACY_STATUS_PROCESSED) return false;\n\n        uint256 _time = confirmAt[_root];\n        if (_time == 0) {\n            return false;\n        }\n        return block.timestamp >= _time;\n    }", "Replica.IMessageRecipient:function\n        IMessageRecipient(_m.recipientAddress()).handle(\n            _m.origin(),\n            _m.nonce(),\n            _m.sender(),\n            _m.body().clone()\n        );\n        // emit process results\n        emit Process(_messageHash, true, \"\");\n        // reset re-entrancy guard\n        entered = 1;\n        // return true\n        return true;\n    }\n\n    // ============ External Owner Functions ============\n\n    /**\n     * @notice Set optimistic timeout period for new roots\n     * @dev Only callable by owner (Governance)\n     * @param _optimisticSeconds New optimistic timeout period\n     */\n    function setOptimisticTimeout(uint256 _optimisticSeconds)\n        external\n        onlyOwner\n    {\n        _setOptimisticTimeout(_optimisticSeconds);\n    }"]}