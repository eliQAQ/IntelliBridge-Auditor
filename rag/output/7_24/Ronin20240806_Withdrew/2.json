{"Function call relationship": "MainchainGatewayV3._submitWithdrawal", "code": ["MainchainGatewayV3._submitWithdrawal:function _submitWithdrawal(Transfer.Receipt calldata receipt, Signature[] memory signatures) internal virtual returns (bool locked) {\n    uint256 id = receipt.id;\n    uint256 quantity = receipt.info.quantity;\n    address tokenAddr = receipt.mainchain.tokenAddr;\n\n    receipt.info.validate();\n    if (receipt.kind != Transfer.Kind.Withdrawal) revert ErrInvalidReceiptKind();\n\n    if (receipt.mainchain.chainId != block.chainid) {\n      revert ErrInvalidChainId(msg.sig, receipt.mainchain.chainId, block.chainid);\n    }\n\n    MappedToken memory token = getRoninToken(receipt.mainchain.tokenAddr);\n\n    if (!(token.erc == receipt.info.erc && token.tokenAddr == receipt.ronin.tokenAddr && receipt.ronin.chainId == roninChainId)) {\n      revert ErrInvalidReceipt();\n    }\n\n    if (withdrawalHash[id] != 0) revert ErrQueryForProcessedWithdrawal();\n\n    if (!(receipt.info.erc == TokenStandard.ERC721 || !_reachedWithdrawalLimit(tokenAddr, quantity))) {\n      revert ErrReachedDailyWithdrawalLimit();\n    }\n\n    bytes32 receiptHash = receipt.hash();\n    bytes32 receiptDigest = Transfer.receiptDigest(_domainSeparator, receiptHash);\n\n    uint256 minimumWeight;\n    (minimumWeight, locked) = _computeMinVoteWeight(receipt.info.erc, tokenAddr, quantity);\n\n    {\n      bool passed;\n      address signer;\n      address lastSigner;\n      Signature memory sig;\n      uint256 weight;\n      for (uint256 i; i < signatures.length; i++) {\n        sig = signatures[i];\n        signer = ecrecover(receiptDigest, sig.v, sig.r, sig.s);\n        if (lastSigner >= signer) revert ErrInvalidOrder(msg.sig);\n\n        lastSigner = signer;\n\n        weight += _getWeight(signer);\n        if (weight >= minimumWeight) {\n          passed = true;\n          break;\n        }\n      }\n\n      if (!passed) revert ErrQueryForInsufficientVoteWeight();\n      withdrawalHash[id] = receiptHash;\n    }\n\n    if (locked) {\n      withdrawalLocked[id] = true;\n      emit WithdrawalLocked(receiptHash, receipt);\n      return locked;\n    }\n\n    _recordWithdrawal(tokenAddr, quantity);\n    receipt.info.handleAssetOut(payable(receipt.mainchain.addr), tokenAddr, wrappedNativeToken);\n    emit Withdrew(receiptHash, receipt);\n  }"]}