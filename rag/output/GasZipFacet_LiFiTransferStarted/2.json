{"Function call relationship": "GasZipFacet.swapAndStartBridgeTokensViaGasZip", "code": ["GasZipFacet.swapAndStartBridgeTokensViaGasZip:function swapAndStartBridgeTokensViaGasZip(\n        ILiFi.BridgeData memory _bridgeData,\n        LibSwap.SwapData[] calldata _swapData,\n        GasZipData calldata _gasZipData\n    )\n        external\n        payable\n        nonReentrant\n        refundExcessNative(payable(msg.sender))\n        containsSourceSwaps(_bridgeData)\n        doesNotContainDestinationCalls(_bridgeData)\n        validateBridgeData(_bridgeData)\n    {\n        // this function shall only be used for ERC20 assets\n        if (LibAsset.isNativeAsset(_bridgeData.sendingAssetId))\n            revert InvalidCallData();\n\n        // deposit and swap ERC20 tokens\n        _bridgeData.minAmount = _depositAndSwap(\n            _bridgeData.transactionId,\n            _bridgeData.minAmount,\n            _swapData,\n            payable(msg.sender)\n        );\n\n        // deposit to gas.zip\n        depositToGasZipNative(\n            _bridgeData.minAmount,\n            _gasZipData.gasZipChainId,\n            _bridgeData.receiver\n        );\n\n        emit LiFiTransferStarted(_bridgeData);\n    }", "LibAsset.isNativeAsset:function isNativeAsset(address assetId) internal pure returns (bool) {\n        return assetId == NATIVE_ASSETID;\n    }", "GasZipFacet.depositToGasZipNative:function depositToGasZipNative(\n        uint256 _amountToZip,\n        uint256 _destinationChains,\n        address _recipient\n    ) public payable {\n        // call the gas zip router and deposit tokens\n        gasZipRouter.deposit{ value: _amountToZip }(\n            _destinationChains,\n            _recipient\n        );\n    }"]}