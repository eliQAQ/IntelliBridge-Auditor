{"Function call relationship": "THORChain_Router.returnVaultAssets", "code": ["THORChain_Router.returnVaultAssets:function returnVaultAssets(address router, address payable asgard, Coin[] memory coins, string memory memo) external payable {\n        if (router == address(this)){\n            for(uint i = 0; i < coins.length; i++){\n                _adjustAllowances(asgard, coins[i].asset, coins[i].amount);\n            }\n            emit VaultTransfer(msg.sender, asgard, coins, memo); // Does not include ETH.           \n        } else {\n            for(uint i = 0; i < coins.length; i++){\n                _routerDeposit(router, asgard, coins[i].asset, coins[i].amount, memo);\n            }\n        }\n        (bool success,) = asgard.call{value:msg.value}(\"\"); //ETH amount needs to be parsed from tx.\n        require(success);\n    }", "THORChain_Router._adjustAllowances:function _adjustAllowances(address _newVault, address _asset, uint _amount) internal {\n        vaultAllowance[msg.sender][_asset] -= _amount;\n        vaultAllowance[_newVault][_asset] += _amount;\n    }", "THORChain_Router._routerDeposit:function _routerDeposit(address _router, address _vault, address _asset, uint _amount, string memory _memo) internal {\n        vaultAllowance[msg.sender][_asset] -= _amount;\n        (bool success,) = _asset.call(abi.encodeWithSignature(\"approve(address,uint256)\", _router, _amount)); // Approve to transfer\n        require(success);\n        iROUTER(_router).depositWithExpiry(_vault, _asset, _amount, _memo, type(uint).max); // Transfer by depositing\n    }"]}